<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python网络编程]]></title>
    <url>%2Faisnnu.github.io%2Funcategorized%2Faisnnu2%2F</url>
    <content type="text"><![CDATA[pyton语言在网络编程中的应用比较广泛。socket模块可以实现网络设备之间的通信；HTTP库可以实现网站服务器与浏览器之前的通信；urllib库可以处理客户端的请求和服务器端的响应，还可以解析URL地址；ftplib模块可以实现文件的上传和下载；电子邮件服务器模块可以实现邮件的发送和接收；telnetlib模块可以连接远程计算机。 网络OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。OSI模型的设计目的是成为一个所有销售商都能实现的开放网路模型，来克服使用众多私有网络模型所带来的困难和低效性。OSI是在一个备受尊敬的国际标准团体的参与下完成的，这个组织就是ISO（国际标准化组织）。什么是OSI，OSI是Open System Interconnection 的缩写，意为开放式系统互联参考模型。在OSI出现之前，计算机网络中存在众多的体系结构，其中以IBM公司的SNA(Systems Network Architecture，系统网络体系结构)和DEC公司的DNA(Digital Network Architecture，数字网络体系结构)最为著名。为了解决不同体系结构的网络的互联问题，国际标准化组织ISO(注意不要与OSI搞混）于1981年制定了开放系统互连参考模型（Open System Interconnection Reference Model，OSI/RM）。这个模型把网络通信的工作分为7层，它们由低到高分别是物理层（Physical Layer)，数据链路层（Data Link Layer)，网络层(Network Layer)，传输层（Transport Layer)，会话层（Session Layer），表示层（Presentation Layer)和应用层（Application Layer)。第一层到第三层属于OSI参考模型的低三层，负责创建网络通信连接的链路；第五层到第七层为OSI参考模型的高三层，具体负责端到端的数据通信；第四层负责高低层的连接。每层完成一定的功能，每层都直接为其上层提供服务，并且所有层次都互相支持，而网络通信则可以自上而下（在发送端）或者自下而上（在接收端）双向进行。当然并不是每一通信都需要经过OSI的全部七层，有的甚至只需要双方对应的某一层即可。物理接口之间的转接，以及中继器与中继器之间的连接就只需在物理层中进行即可；而路由器与路由器之间的连接则只需经过网络层以下的三层即可。总的来说，双方的通信是在对等层次上进行的，不能在不对称层次上进行通信。 OSI分层原则网络中各结点都有相同的层次 不同结点相同层次具有相同的功能 同一结点相邻层间通过接口通信 每一层可以使用下层提供的服务，并向上层提供服务 不同结点的同等层间通过协议来实现对等层间的通信 OSIOSI/RM分层对等层通信的实质： 对等层实体之间虚拟通信；下层向上层提供服务；实际通信在最底层完成；发送方数据由最高层逐渐向下层传递，到接收方数据由最低层逐渐向高层传递。 协议数据单元PDUOSI参考模型中，对等层协议之间交换的信息单元统称为协议数据单元(PDU，Protocol Data Unit)。 而传输层及以下各层的PDU另外还有各自特定的名称： 传输层——数据段（Segment） 网络层——分组（数据包）（Packet） 数据链路层——数据帧（Frame） 物理层——比特（Bit） 物理层（Physical Layer）物理层是OSI分层结构体系中最重要、最基础的一层，它建立在传输媒介基础上，起建立、维护和取消物理连接作用，实现设备之间的物理接口。物理层之接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。 物理层包括对连接到网络上的设备描述其各种机械的、电气的、功能的规定。具体地讲，机械特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了DTE（数据终端设备）和DCE（数据通信设备）之间各个线路的功能；过程特性定义了利用信号线进行bit流传输的一组操作规程，是指在物理连接的建立、维护、交换信息时，DTE和DCE双方在各电路上的动作系列。物理层的数据单位是位。 属于物理层定义的典型规范代表包括：EIA/TIARS-232、EIA/TIARS-449、V.35、RJ-45等。 物理层的主要功能：·为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接，传送数据，终止物理连接。所谓激活，就是不管有多少物理媒体参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。 ·传输数据。物理层要形成适合数据传输需要的实体，为数据传送服务： 一、保证数据按位传输的正确性； 二、向数据链路层提供一个透明的位传输； 三、提供足够的带宽(带宽是指每秒钟内能通过的比特(BIT)数)，以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。 完成物理层的一些管理工作，如在数据终端设备、数据通信和交换设备等设备之间完成对数据链路的建立、保持和拆除操作。 物理层的典型设备：光纤、同轴电缆、双绞线、中继器和集线器 数据链路层（Data Link Layer）在物理层提供比特流服务的基础上，将比特信息封装成数据帧Frame，起到在物理层上建立、撤销、标识逻辑链接和链路复用以及差错校验等功能。通过使用接收系统的硬件地址或物理地址来寻址。建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，同时为其上面的网络层提供有效的服务。 数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 在这一层，数据的单位称为帧（frame）。 数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。 链路层的主要功能：·链路层的功能是实现系统实体间二进制信息块的正确传输 ·为网络层提供可靠无错误的数据信息 ·在数据链路中解决信息模式、操作模式、差错控制、流量控制、信息交换过程和通信控制规程的问题 链路层是为网络层提供数据传送服务的，这种服务要依靠本层具备的功能来实现。链路层应具备如下功能： ·链路连接的建立，拆除，分离。 ·帧定界和帧同步。链路层的数据传输单元是帧，协议不同，帧的长短和界面也有差别，但无论如何必须对帧进行定界。 ·顺序控制，指对帧的收发顺序的控制。 ·差错检测和恢复。还有链路标识，流量控制等等。差错检测多用方阵码校验和循环码校验来检测信道上数据的误码，而帧丢失等用序号检测。各种错误的恢复则常靠反馈重发技术来完成。 数据链路层的典型设备：二层交换机、网桥、网卡 网络层（Network Layer）网络层也称通信子网层，是高层协议之间的界面层，用于控制通信子网的操作，是通信子网与资源子网的接口。在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将解封装数据链路层收到的帧，提取数据包，包中封装有网络层包头，其中含有逻辑地址信息源站点和目的站点地址的网络地址。 如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地址解析协议（ARP）。有关路由的一切事情都在第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连、信息包顺序控制及网络记账等功能。 在网络层交换的数据单元的单位是分割和重新组合数据包（packet）。 网络层协议的代表包括：IP、IPX、OSPF等。 网络层主要功能是基于网络层地址（IP地址）进行不同网络系统间的路径选择。 网络层主要功能网络层为建立网络连接和为上层提供服务，应具备以下主要功能： ·路由选择和中继； ·激活，终止网络连接； ·在一条数据链路上复用多条网络连接，多采取分时复用技术； ·差错检测与恢复； ·排序，流量控制； ·服务选择； ·网络管理； 网络层典型设备：网关、路由器 传输层（Transport Layer）传输层建立在网络层和会话层之间，实质上它是网络体系结构中高低层之间衔接的一个接口层。用一个寻址机制来标识一个特定的应用程序（端口号）。传输层不仅是一个单独的结构层，它还是整个分层体系协议的核心，没有传输层整个分层协议就没有意义。 传输层的数据单元是由数据组织成的数据段（segment）这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。 传输层获得下层提供的服务包括： ·发送和接收正确的数据块分组序列，并用其构成传输层数据； ·获得网络层地址，包括虚拟信道和逻辑信道。 传输层向上层提供的服务包括： ·无差错的有序的报文收发； ·提供传输连接； ·进行流量控制。 传输层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务，所谓透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。 传输层协议的代表包括：TCP、UDP、SPX等。 传输层主要功能传输层的主要功能是从会话层接收数据，根据需要把数据切成较小的数据片，并把数据传送给网络层，确保数据片正确到达网络层，从而实现两层数据的透明传送。 传输层是两台计算机经过网络进行数据通信时，第一个端到端的层次，具有缓冲作用。当网络层服务质量不能满足要求时，它将服务加以提高，以满足高层的要求；当网络层服务质量较好时，它只用很少的工作。传输层还可进行复用，即在一个网络连接上创建多个逻辑连接。 传输层也称为运输层。传输层只存在于端开放系统中，是介于低三层通信子网系统和高三层之间的一层，但是很重要的一层。因为它是源端到目的端对数据传送进行控制从低到高的最后一层。 有一个既存事实，即世界上各种通信子网在性能上存在着很大差异。例如电话交换网、分组交换网、公用数据交换网、局域网等通信子网都可互连，但它们提供的吞吐量、传输速率、数据延迟通信费用各不相同。对于会话层来说，却要求有一性能恒定的界面。传输层就承担了这一功能。它采用分流/合流、复用/介复用技术来调节上述通信子网的差异，使会话层感受不到。 此外传输层还要具备差错恢复、流量控制等功能，以此对会话层屏蔽通信子网在这些方面的细节与差异。传输层面对的数据对象已不是网络地址和主机地址，而是和会话层的界面端口。上述功能的最终目的是为会话提供可靠的、无误的数据传输。传输层的服务一般要经历传输连接建立阶段、数据传送阶段、传输连接释放阶段3个阶段才算完成一个完整的服务过程。而在数据传送阶段又分为一般数据传送和加速数据传送两种。传输层服务分成5种类型。基本可以满足对传送质量、传送速度、传送费用的各种不同需要。 会话层（Session Layer）这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。 会话层提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。会话层、表示层、应用层构成开放系统的高3层，面对应用进程提供分布处理，对话管理，信息表示，恢复最后的差错等。会话层同样要担负应用进程服务要求，而运输层不能完成的那部分工作，给运输层功能差距以弥补。主要的功能是对话管理，数据流同步和重新同步。要完成这些功能，需要由大量的服务单元功能组合，已经制定的功能单元已有几十种。 会话层的主要功能·会话层连接到传输层的映射； ·会话连接的流量控制； ·数据传输； ·会话连接恢复与释放； ·会话连接管理、差错控制。 为会话实体间建立连接、为给两个对等会话服务用户建立一个会话连接，应该做如下几项工作： ·将会话地址映射为运输地址； ·选择需要的运输服务质量参数(QOS)； ·对会话参数进行协商； ·识别各个会话连接； ·传送有限的透明用户数据； ·数据传输阶段。 这个阶段是在两个会话用户之间实现有组织的，同步的数据传输。用户数据单元为SSDU，而协议数据单元为SPDU。会话用户之间的数据传送过程是将SSDU转变成SPDU进行的。 连接释放 连接释放是通过”有序释放”、”废弃”、”有限量透明用户数据传送”等功能单元来释放会话连接的。会话层标准为了使会话连接建立阶段能进行功能协商，也为了便于其它国际标准参考和引用，定义了12种功能单元。各个系统可根据自身情况和需要，以核心功能服务单元为基础，选配其他功能单元组成合理的会话服务子集。会话层的主要标准有”DIS8236:会话服务定义”和”DIS8237:会话协议规范”。 表示层（Presentation Layer）表示层向上对应用层提供服务，向下接收来自会话层的服务。表示层是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。例如图像格式的显示，就是由位于表示层的协议来支持。 表示层为应用层提供服务包括语法选择、语法转换等。语法选择是提供一种初始语法和以后修改这种选择的手段。语法转换涉及代码转换和字符集的转换、数据格式的修改以及对数据结构操作的适配。 应用层（Application Layer）网络应用层是通信用户之间的窗口，为用户提供网络管理、文件传输、事务处理等服务。其中包含了若干个独立的、用户通用的服务协议模块。网络应用层是OSI的最高层，为网络用户之间的通信提供专用的程序。应用层的内容主要取决于用户的各自需要，这一层设计的主要问题是分布数据库、分布计算技术、网络操作系统和分布操作系统、远程文件传输、电子邮件、终端电话及远程作业登录与控制等。至2011年应用层在国际上没有完整的标准，是一个范围很广的研究领域。在OSI的7个层次中，应用层是最复杂的，所包含的应用层协议也最多，有些还在研究和开发之中。 应用层为操作系统或网络应用程序提供访问网络服务的接口。 应用层协议的代表包括：Telnet、FTP、HTTP、SNMP、DNS等。 通过 OSI 层，信息可以从一台计算机的软件应用程序传输到另一台的应用程序上。例如，计算机 A 上的应用程序要将信息发送到计算机 B 的应用程序，则计算机 A 中的应用程序需要将信息先发送到其应用层（第七层），然后此层将信息发送到表示层（第六层），表示层将数据转送到会话层（第五层），如此继续，直至物理层（第一层）。在物理层，数据被放置在物理网络媒介中并被发送至计算机 B 。计算机 B 的物理层接收来自物理媒介的数据，然后将信息向上发送至数据链路层（第二层），数据链路层再转送给网络层，依次继续直到信息到达计算机 B 的应用层。最后，计算机 B 的应用层再将信息传送给应用程序接收端，从而完成通信过程。 OSI 的七层运用各种各样的控制信息来和其他计算机系统的对应层进行通信。这些控制信息包含特殊的请求和说明，它们在对应的 OSI 层间进行交换。每一层数据的头和尾是两个携带控制信息的基本形式。 对于从上一层传送下来的数据，附加在前面的控制信息称为头，附加在后面的控制信息称为尾。然而，在对来自上一层数据增加协议头和协议尾，对一个 OSI 层来说并不是必需的。 当数据在各层间传送时，每一层都可以在数据上增加头和尾，而这些数据已经包含了上一层增加的头和尾。协议头包含了有关层与层间的通信信息。头、尾以及数据是相关联的概念，它们取决于分析信息单元的协议层。例如，传输层头包含了只有传输层可以看到的信息，传输层下面的其他层只将此头作为数据的一部分传递。对于网络层，一个信息单元由第三层的头和数据组成。对于数据链路层，经网络层向下传递的所有信息即第三层头和数据都被看作是数据。换句话说，在给定的某一 OSI 层，信息单元的数据部分包含来自于所有上层的头和尾以及数据，这称之为封装。 例如，如果计算机 A 要将应用程序中的某数据发送至计算机 B ，数据首先传送至应用层。 计算机 A 的应用层通过在数据上添加协议头来和计算机 B 的应用层通信。所形成的信息单元包含协议头、数据、可能还有协议尾，被发送至表示层，表示层再添加为计算机 B 的表示层所理解的控制信息的协议头。信息单元的大小随着每一层协议头和协议尾的添加而增加，这些协议头和协议尾包含了计算机 B 的对应层要使用的控制信息。在物理层，整个信息单元通过网络介质传输。 计算机 B 中的物理层收到信息单元并将其传送至数据链路层；然后 B 中的数据链路层读取计算机 A 的数据链路层添加的协议头中的控制信息；然后去除协议头和协议尾，剩余部分被传送至网络层。每一层执行相同的动作：从对应层读取协议头和协议尾，并去除，再将剩余信息发送至上一层。应用层执行完这些动作后，数据就被传送至计算机 B 中的应用程序，这些数据和计算机 A 的应用程序所发送的完全相同 。 一个 OSI 层与另一层之间的通信是利用第二层提供的服务完成的。相邻层提供的服务帮助一 OSI 层与另一计算机系统的对应层进行通信。一个 OSI 模型的特定层通常是与另外三个 OSI 层联系：与之直接相邻的上一层和下一层，还有目标联网计算机系统的对应层。例如，计算机 A 的数据链路层应与其网络层，物理层以及计算机 B 的数据链路层进行通信。 网络的连接有两种类型：以连接为导向和以包为导向 socket模块socket由一些对象组成，这些对象提供网络应用程序的跨平台标准。 认识socket模块socket又称“套接字”，应用程序通常通过“套接字”向网络发出请求或应答网络请求，使主机间或一台计算机上的进程可以通信。socket模块提供了标准的网络接口，可以访问底层操作系统socket接口的全部方法。 Python使用socket()函数创建套接字，其语法格式如下： socket.socket([family[, type[,protocol]]]) 各个参数的含义如下： （1）family：套接字中的网络协议，包括AF_UNTX(UNTX网域协议)或AF_INET(IPv4网域协议，如TCP与UDP)。（2）type：套接字类型，包括SOCK_STREAM(使用在TCP协议)、SOCK_DGRAM(使用在UDP协议)、SOCK_RAW(使用在IP协议)和SOCK_SEQPACKET(列表连接模式)。（3）protocol：只使用在family等于AF_INET或type等于SOCK_RAW的时候。protocol是一个常数，用于辨识所使用的协议种类。默认值是0，表示适用于所有的socket类型。 创建socket连接下面使用socket模块的socket函数创建一个socket对象。socket对象可以通过调用其他函数设置一个socket服务。通过调用bind(hostname,port)函数指定服务的port(端口)，然后调用socket对象的accept方法，该方法等待客户端的连接并返回connection对象，表示已连接到该客户端。 1234567891011121314151617181920212223242526272829#创建服务器端的socket服务# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象serversocket = socket.socket( socket.AF_INET, socket.SOCK_STREAM) # 获取本地主机名host = socket.gethostname()port = 9999# 绑定端口serversocket.bind((host, port))# 设置最大连接数，超过后排队serversocket.listen(5)while True: # 建立客户端连接 clientsocket,addr = serversocket.accept() print(&quot;连接地址: %s&quot; % str(addr)) msg=&apos;莫使金樽空对月，还须怜取眼前人&apos;+ &quot;\r\n&quot; clientsocket.send(msg.encode(&apos;utf-8&apos;)) clientsocket.close() 保存并运行程序，即可在服务器端启动socket服务。 下面演示如何创建一个客户端，并连接到以上服务，端口号为12345。 123456789101112131415161718192021222324#创建客户端的连接# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 获取本地主机名host = socket.gethostname() # 设置端口号port = 9999# 连接服务，指定主机和端口s.connect((host, port))# 接收小于 1024 字节的数据msg = s.recv(1024)s.close()print (msg.decode(&apos;utf-8&apos;)) 保存并运行程序。 HTTP库HTTP是一个客户端到服务器端的请求和应答的标准。客户端是终端用户，服务器端是网站。客户端发起一个到服务器上指定端口的HTTP请求，服务器向客户端发回一个状态行和响应的消息。可以使用下面的模块创建Internet Server。（1）socketserver：以socket为基础，一般性的IP Server。（2）http：通过http模块中的子模块server和client提供各种网络服务。 socketserver模块socketserver模块提供一个架构，来简化网络服务器的编写工作。用户不需要使用低级的socket模块，socketserver模块提供四个基本的server类：TCPServer，UDPServer，StreamRequestHandler以及DatagramRequestHandler。这些类处理同步的要求，每一个请求都必须在下一个请求开始前完成。但是如果是客户端需要长时间的计算，这些类就不适合。 为了通过线程程来处理要求，可以使用下列类：ThreadingTCPServer，ThreadingUDPServer，ForkingTCPServer以及ForkingUDPServer。 （1）TCPServer((hostname,port),handler):支持TCP协议的服务器。其中，hostname是主机名称，通常是空白字符串；port是通信端口号；handler是BaseRequestHandler类的实例变量。（2）UDPServer((hostname,port),handler):支持UDP协议的服务器。其中，hostname是主机名称，通常是空白字符串；port是通信端口号；handler是BaseRequestHandler类的实例变量。 server模块http模块的子模块server提供各种HTTP服务。主要包括BaseHTTPServer类、CGIHTTPServer类与SimpleHTTPServer类。server模块定义两个基类，来操作基本的HTTP服务器(也称为网站服务器)。此模块以socketserver模块为基础，并且很少直接使用。server模块的第一个基类是HTTPServer类，其语法为：class HTTPServer((hostname, port), RequestHandlerClass)HTTPServer类由socketserver.TCPServer类派生。此类创建一个HTTPServer对象，并且监听(hostname, port)，然后使用RequestHandlerClass来处理要求。 client模块client模块主要处理客户端的请求。client模块的HTTPConnection类创建并且返回一个connection对象。HTTPConnection类的语法如下：class HTTPConnection ([hostname [, port]])如果没有设置参数port，默认值是80。如果所有的参数都没有设置，必须使用connect()方法来自行连接。使用HTTPConnection类1234567891011121314151617181920212223242526import http.client#指定主机名称url = &quot;www.python.org&quot;#指定打开的文件名称urlfile = &quot;/News.html&quot;#连接到主机host = http.client.HTTPConnection (url)#写入客户端要求表头的第一行host.request(&quot;GET&quot;, urlfile)#获取服务器的响应r1=host.getresponse()#打印服务器返回的状态print(r1.status,r1.reason)#将file对象的内容存入新文件file = open(&quot;D:\\python\\ch14\\14.1.html&quot;, &quot;w&quot;)#读取网页内容,以utf-8方式保存str = r1.read().decode(&quot;utf-8&quot;)#寻找文本print(str.find(&quot;mlive&quot;)) #写到文件并替换 &apos;xa0&apos; 为空字符file.write(str.replace(&apos;\xa0&apos;,&apos;&apos;)) #关闭文件file.close() urllib库urllib库可以处理客户端的请求和服务器端的响应，还可以解析URL地址，常用的模块有request和parse。 request模块request模块是使用socket来读取网络数据的接口，支持HTTP，FTP，以及gopher等连接。要读取一个网页文件，可以使用urlopen()方法。语法如下：urllib.request.urlopen(url [, data])其中参数url是一个URL字符串；参数data用来指定一个GET请求。urlopen()方法返回一个stream对象，可以用file对象的方法来操作此stream对象。 下面用urlopen方法抓取网页文件 12345678910111213141516171819import urllib.request#打开网页文件htmlhandler = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)#在本机上创建一个新文件file = open(&quot;C:\\python\\2.html&quot;, &quot;wb&quot;)#将网页文件存储到本机文件上,每次读取512个字节while 1: data = htmlhandler.read(512) if not data: break file.write(data)#关闭本机文件file.close()#关闭网页文件htmlhandler.close() parse模块parse模块解析URL字符串，并且返回一个元组：(addressing scheme, netword location, path, parameters, query, fragment identifier)。parse模块可以将URL分解成数个部分，然后再组合回来，并且可以将相对地址转换成绝对地址。 FTP模块FTP(File Transfer Protocol)是一种在网络上传输文件的普遍方式，因为在大部分的操作系统上都有客户端的FTP与服务器端的FTP服务。服务器端的FTP可以同时使用在私有(private)的用户，与匿名(anonymous)的用户。私有的服务器端FTP只允许系统用户来连接，匿名的服务器端FTP则允许不需帐号即可以连接网络来传输文件。使用匿名的服务器端FTP，会产生安全性的问题。FTP提供一个控制端口与一个数据端口，在服务器端与客户端之间的数据传输使用独立的socket，以避免死机的问题。Python中默认安装的ftplib模块定义了FTP类，可用来创建一个FTP连接，用于上传或下载文件。FTP类的语法如下所示：class FTP([host [, user [, passwd [, acct]]]])其中host是主机名称，user是用户帐号，passwd是用户密码。 上传FTP文件 12345678910111213141516171819202122232425262728293031from ftplib import FTPftp = FTP()timeout = 30port = 21# 连接FTP服务器ftp.connect(&apos;192.168.1.106&apos;,port,timeout) # 登录FTP服务器ftp.login(&apos;adminns&apos;,&apos;123456&apos;) # 获得欢迎信息print (ftp.getwelcome())ftp.cwd(&apos;file/test&apos;) # 设置FTP路径list = ftp.nlst() # 获得目录列表# 打印文件名字for name in list: print(name) # 文件保存路径path = &apos;d:/data/&apos; + name # 打开要保存文件f = open(path,&apos;wb&apos;) # 保存FTP文件filename = &apos;RETR &apos; + name # 保存FTP上的文件ftp.retrbinary(filename,f.write) # 删除FTP文件ftp.delete(name) # 上传FTP文件ftp.storbinary(&apos;STOR &apos;+filename, open(path, &apos;rb&apos;)) # 退出FTP服务器ftp.quit() 电子邮件服务协议SMPT协议与POP3协议提供电子邮件服务。SMPT是网络上传输电子邮件的标准，定义应用程序如何在网络上交换电子邮件。SMPT协议负责将电子邮件放在电子邮箱内。若要从电子邮箱内取出电子邮件，则需要POP3协议。POP3负责从网络客户端读取邮件，并指定由监督武器如何传输电子邮件。POP3协议的目的是存取远程的外部服务器。 smptlib模块Python的smptlib模块提供SMTP协议的客户端接口，用来传输电子邮件到网络上的其他机器。smptlib模块定义一个SMTP类，用来创建一个SMTP连接。SMTP类的语法如下所示：class SMTP([host [, port]])其中参数host是主机名称。下列是SMTP类的实例变量的方法列表：⑴ connect(host [, port])：连接到(host, port)，port的默认值是25。⑵ sendmail(from_addr, to_addrs, msg [, mail_options, rcpt_options])：送出电子邮件。from_addr是RFC 822 from-address字符串，to_addr是RFC 822 to-address字符串。msg是一个信息字符串。⑶ quit()：结束SMTP连接。 1234567891011121314151617181920212223242526import smtplib#指定SMTP服务器host = &quot;smtp.163.com&quot;#寄件者的电子邮件信箱sender = &quot; chengcai@163.com &quot;#收件者的电子邮件信箱receipt = &quot; sanduo@163.com &quot;#电子邮件的内容msg = &quot;&quot;&quot;您好: 这是一个测试的电子邮件&quot;&quot;&quot;#创建SMTP类的实例变量myServer = smtplib.SMTP(host)#寄出电子邮件myServer.sendmail(sender, receipt, msg)#关闭连接myServer.quit() poplib模块Python的poplib模块提供POP3协议的客户端接口，用来从网络上接收电子邮件。poplib模块定义一个POP3类，用来创建一个POP3连接。POP3类的语法如下所示：class POP3([host [, port]])其中host是主机名称，port的默认值是110。 1234567891011121314151617181920212223242526272829import poplib, string#指定POP服务器host = &quot;saturn.seed.net.tw&quot;#创建一个POP3类的实例变量myServer = poplib.POP3(host)#返回POP3服务器送出的欢迎字符串print (myServer.getwelcome())#输入电子邮件的帐号myServer.user(&quot;johnny&quot;)#输入电子邮件的密码myServer.pass_(&quot;123456&quot;)#返回信息列表r, items, octets = myServer.list()#读取最后一个信息msgid, size = string.split(items[-1])#返回最后一个信息号码的内容r, msg, octets = myServer.retr(msgid)msg = string.join(msg, &quot;\n&quot;)#打印后一个信息号码的内容print (msg) imaplib模块Python的imaplib模块提供IMAP协议的客户端接口。imaplib模块定义一个IMAP4类，用来创建一个IMAP连接。IMAP4类的语法如下所示：class IMAP4([host [, port]])其中host是主机名称，port的默认值是163。下列是IMAP4类的实例变量的方法列表：⑴ fetch(message_set, message_parts)：取出信息。⑵ login(user, password)：登录IMAP4服务器。⑶ logout()：注销IMAP4服务器，关闭连接。⑷ search(charset, criterium [, …])：搜索邮件信箱找出符合的信息。⑸ select([mailbox [, readonly]])：选择一个邮件信箱。 123456789101112131415import imaplib, getpass, stringhost = &quot;imap.dummy.com&quot;user = &quot;jonny&quot;pwd = getpass.getpass()msgserver = imaplib.IMAP4(host)msgserver.login(user, pwd)msgserver.select()msgtyp, msgitems = msgserver.search(None, &quot;ALL&quot;)for idx in string.split(msgitems[0]): msgtyp, msgitems = msgserver.fetch(idx, &quot;(RFC822)&quot;) print (&quot;Message %s\n&quot; % num) print (&quot;---------------\n&quot;) print (&quot;Content: %s&quot; % msgitems[0][1])msgserver.logout() nntp模块nntplib模块提供客户端的NNTP协议的接口，NNTP(Network News Transfer Protocol)是一个提供新闻群组(newsgroup)的服务。NNTP协议使用ASCII文字，在客户端与服务器端之间传输数据，同时也用来交换服务器间的新闻稿。nntplib模块定义一个NNTP类，用来创建一个NNTP连接。NNTP类的语法如下所示：class NNTP(host [, port [, user [, password [, readermode]]]])其中host是主机名称，port的默认值是119。 1234567891011121314151617181920212223242526272829303132333435363738import nntplibimport string#指定NNTP服务器host = &quot;news.microsoft.com&quot;#指定新闻群组group = &quot;microsoft.public.java.activex&quot;#输入要搜索的关键词keyword = raw_input(&quot;Enter keyword to search: &quot;)#连结到NNTP服务器myServer = nntplib.NNTP(host)#送出一个&quot;GROUP&quot;命令r, count, first, last, name = myServer.group(group)#返回所有的新闻稿r, messages = myServer.xover(first, last)#读取新闻稿的内容for id, subject, author, date, msgid, refer, size, lines in messages: #找到新闻稿中的主题有要搜索的关键词 if string.find(subject, keyword) &gt;= 0: #读取id号码的新闻稿 r, id, msgid, msgbody = myServer.article(id) #打印该新闻稿的作者,主题,与日期 print (&quot;Author: %s - Subject: %s - Date: %s\n&quot; % (author, subject, date)) #打印该新闻稿的内容 print (&quot;&lt;-Begin Message-&gt;\n&quot;) print (msgbody) print (&quot;&lt;-End Message-&gt;\n&quot;) telnetlib模块telnetlib模块提供客户端的Telnet协议的服务，Telnet协议用来连接远程的计算机，通常使用通信端口23。创建好Telnet连接后，就可以通过Telnet接口在远程的计算机上执行命令。telnetlib模块定义一个Telnet类，用来创建一个Telnet连接。Telnet类的语法规则如下所示：class Telnet([host [, port]])其中host是主机名称，port的默认值是23。 123456789101112131415161718192021222324252627import telnetlib#指定Telnet服务器host = &quot;http://www.dummy.com&quot;#指定用户帐号username = &quot;johnny&quot; + &quot;\n&quot;#指定用户密码password = &quot;123456&quot; + &quot;\n&quot;#创建Telnet类的实例变量telnet = telnetlib.Telnet(host)#登入Telnet服务器,输入用户帐号与密码telnet.read_until(&quot;login: &quot;)telnet.write(username)telnet.read_until(&quot;Password: &quot;)telnet.write(password)#输入命令while 1: command = raw_input(&quot;[shell]: &quot;) telnet.write(command) if command == &quot;exit&quot;: break telnet.read_all()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适用于渗透测试不同阶段的工具收集整理]]></title>
    <url>%2Faisnnu.github.io%2Funcategorized%2Faisnnu1%2F</url>
    <content type="text"><![CDATA[该资源清单列表涵盖了一系列，适用于渗透测试不同阶段的开源/商业工具。 侦察主动情报收集EyeWitness：可用于网站截图，以及提供一些服务器头信息，并在可能的情况下识别默认凭据。 https://github.com/ChrisTruncer/EyeWitness AWSBucketDump：AWS S3安全扫描工具，允许你快速枚举AWS S3 buckets以查找有趣或机密的文件。 https://github.com/jordanpotti/AWSBucketDump AQUATONE：子域名枚举探测工具。 https://github.com/michenriksen/aquatone spoofcheck：检查域是否可以被欺骗。它会检查SPF和DMARC记录是否存在允许欺骗的弱配置。 https://github.com/BishopFox/spoofcheck Nmap：用于发现计算机网络上的主机和服务。 https://github.com/nmap/nmap dnsrecon：DNS枚举脚本。 https://github.com/darkoperator/dnsrecon 被动情报收集skiptracer：OSINT爬虫框架，利用PII paywall网站的一些基本python webscraping (BeautifulSoup) 来被动信息收集。 https://github.com/xillwillx/skiptracer ScrapedIn：用于爬取LinkedIn的工具，不受API数据侦察的限制。 https://github.com/dchrastil/ScrapedIn FOCA：主要用于在其扫描的文档中查找元数据和隐藏信息的工具。 https://github.com/ElevenPaths/FOCA The Harvester：是一个社会工程学工具，它通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。 https://github.com/laramies/theHarvester Metagoofil：提取目标网站可用公共文档（如pdf，doc，xls，ppt等）元数据的工具。 https://github.com/laramies/metagoofil SimplyEmail：快速而简单的电子邮件侦察工具。 https://github.com/killswitch-GUI/SimplyEmail truffleHog：帮助开发人员检测他们在GitHub上发布的项目是否已经不小心泄漏了任何秘密密钥。 https://github.com/dxa4481/truffleHog Just-Metadata：一个收集和分析有关IP地址元数据的工具，并试图找到大型数据集内系统之间的关系。 https://github.com/ChrisTruncer/Just-Metadata typofinder：域名拼写错误检索工具。 https://github.com/nccgroup/typofinder 框架Maltego：一款十分适合渗透测试人员和取证分析人员的优秀工具,其主要功能是开源情报收集和取证。 https://www.paterva.com/web7/downloads.php SpiderFoot：免费开源的网站信息收集类工具。 https://github.com/smicallef/spiderfoot datasploit：OSINT框架，用于对公司，人员，电话号码，比特币地址等执行各种侦察技术，汇总所有原始数据，并以多种格式提供数据。 https://github.com/DataSploit/datasploit Recon-ng：Python编写的全功能Web侦察框架。 https://bitbucket.org/LaNMaSteR53/recon-ng 武器化Composite Moniker：CVE-2017-8570 PoC。 https://github.com/rxwx/CVE-2017-8570 Exploit toolkit CVE-2017-8759：一个方便的python脚本，它为测试者和安全研究人员提供了一种快速有效的方式来测试Microsoft .NET Framework RCE。 https://github.com/bhdresh/CVE-2017-8759 CVE-2017-11882 Exploit：最多接受超过17k字节长度的命令/代码。 https://github.com/unamer/CVE-2017-11882 Adobe Flash Exploit：CVE-2018-4878。 https://github.com/anbai-inc/CVE-2018-4878 Exploit toolkit CVE-2017-0199：一个方便的python脚本，它为测试人员和安全研究人员提供了一种快速有效的方式来测试Microsoft Office RCE。 https://github.com/bhdresh/CVE-2017-0199 demiguise：HTA加密工具。 https://github.com/nccgroup/demiguise Office-DDE-Payloads：收集脚本和模板以生成嵌入DDE的Office文档，无宏命令执行技术。 https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads CACTUSTORCH：是一个生成payload的框架,可用于基于James Forshaw的DotNetToJScript工具的攻防对抗。 https://github.com/mdsecactivebreach/CACTUSTORCH SharpShooter：用于检索和执行任意CSharp源码的payload创建框架。 https://github.com/mdsecactivebreach/SharpShooter Don’t kill my cat：用于生成被存储在polyglot图像中的混淆shellcode。 https://github.com/Mr-Un1k0d3r/DKMC Malicious Macro Generator Utility：生成混淆宏，其中还包括AV/Sandboxes逃避机制。 https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator SCT Obfuscator：Cobalt Strike SCT有效载荷混淆器。 https://github.com/Mr-Un1k0d3r/SCT-obfuscator Invoke-Obfuscation：PowerShell混淆器。 https://github.com/danielbohannon/Invoke-Obfuscation Invoke-DOSfuscation：powershell混淆编码框架。 https://github.com/danielbohannon/Invoke-DOSfuscation Unicorn：使用PowerShell降级攻击并将shellcode直接注入内存的工具。 https://github.com/trustedsec/unicorn Shellter：一个动态的shellcode注入工具，也是有史以来第一个真正动态的PE注入工具。 https://www.shellterproject.com/ SigThief：是一个由python编写的,可以用于劫持合法的数字签名并绕过Windows的哈希验证机制的脚本工具。 https://github.com/secretsquirrel/SigThief Veil：用于生成绕过常用AV的metasploit有效载荷的工具。 https://github.com/Veil-Framework/Veil CheckPlease：用PowerShell，Python，Go，Ruby，C，C＃，Perl和Rust编写的CheckPlease Sandbox evasion模块。 https://github.com/Arvanaghi/CheckPlease Invoke-PSImage：将目标PS脚本嵌入到一个PNG图片文件的像素点中，并允许我们使用一行指令来执行该脚本。 https://github.com/peewpw/Invoke-PSImage LuckyStrike：基于PowerShell的实用程序，用于创建恶意的Office宏文档。仅用于渗透测试或教育目的。 https://github.com/curi0usJack/luckystrike ClickOnceGenerator：适用于红队的快速恶意ClickOnce生成器。 https://github.com/Mr-Un1k0d3r/ClickOnceGenerator macro_pack：一个用于自动生成混淆过的MS Office文档、VB脚本等其他格式的工具,其主要目的是用于渗透测试、demo以及社会工程学的评估。 https://github.com/sevagas/macro_pack StarFighters：基于JavaScript和VBScript的Empire启动器。 https://github.com/Cn33liz/StarFighters nps_payload：专为逃避入侵检测而生成Payload的工具。 https://github.com/trustedsec/nps_payload SocialEngineering：负责收集用于证书盗窃和鱼叉式网络钓鱼攻击的社交工程技巧和payloads。 https://github.com/bhdresh/SocialEngineeringPayloads Social-Engineer Toolkit：一款专为社交工程设计的开源渗透测试框架。 https://github.com/trustedsec/social-engineer-toolkit Phishery：一个支持SSL简单的HTTP服务器。 https://github.com/ryhanson/phishery PowerShdll：使用rundll32运行PowerShell。绕过软件限制。 https://github.com/p3nt4/PowerShdll Ultimate AppLocker ByPass List：常用AppLocker绕过技术存储库。 https://github.com/api0cradle/UltimateAppLockerByPassList Ruler：是一款能够通过MAPI/HTTP协议与Exchange服务器交互的工具。 https://github.com/sensepost/ruler Generate-Macro：一个独立的PowerShell脚本，它将生成具有指定有效负载和持久性方法的恶意Microsoft Office文档。 https://github.com/enigma0x3/Generate-Macro Malicious Macro MSBuild Generator ：生成恶意宏并通过MSBuild应用程序白名单绕过执行Powershell或Shellcode。 https://github.com/infosecn1nja/MaliciousMacroMSBuild Meta Twin：一个文件资源克隆器。从一个文件中提取元数据，包括数字签名，并注入到另一个文件中。 https://github.com/threatexpress/metatwin WePWNise：生成独立于体系结构的VBA代码，用于Office文档或模板，并自动绕过应用程序控制。 https://github.com/mwrlabs/wePWNise DotNetToJScript：能够利用JS/Vbs脚本加载.Net程序的工具。 https://github.com/tyranid/DotNetToJScript PSAmsi：一个审计和攻击 AMSI 签名的工具。 https://github.com/cobbr/PSAmsi Reflective DLL injection：是一种库注入技术，让DLL自身不使用LoadLibraryA函数,将自身映射到目标进程内存中。 https://github.com/stephenfewer/ReflectiveDLLInjection ps1encode：用于生成和编码基于powershell的metasploit有效载荷。 https://github.com/CroweCybersecurity/ps1encode Worse PDF：将一个普通的PDF文件变成恶意文件。用于从Windows机器上窃取Net-NTLM哈希。 https://github.com/3gstudent/Worse-PDF SpookFlare：一款可帮助你有机会绕过各种安全措施的工具，例如客户端检测和网络端检测的端点策略。SpookFlare还是Meterpreter，Empire，Koadic等的loader/dropper生成器。 https://github.com/hlldz/SpookFlare GreatEST：是一个生成应用程序白名单绕过的开源项目。此工具适用于红蓝对抗。 https://github.com/GreatSCT/GreatSCT nps：运行没有PowerShell的PowerShell。 https://github.com/Ben0xA/nps Meterpreter_Paranoid_Mode.sh：一个可以创建SSL/TLS shell连接的脚本。 https://github.com/r00t-3xp10it/Meterpreter_Paranoid_Mode-SSL The Backdoor Factory：一款安全测试工具,可以轻松的生成win32PE后门测试程序,ELF文件后门程序等。 https://github.com/secretsquirrel/the-backdoor-factory MacroShop：一组脚本，通过Office宏传递有效载荷。 https://github.com/khr0x40sh/MacroShop UnmanagedPowerShell：可以从一个非托管程序来执行PowerShell , 经过一些修改后也可以被用来注入到其他进程。 https://github.com/leechristensen/UnmanagedPowerShell Delivery钓鱼King Phisher：一款专业的钓鱼活动工具包。 https://github.com/securestate/king-phisher FiercePhish：是一个管理所有钓鱼攻击的完整钓鱼框架 ，允许你跟踪单独的网络钓鱼活动，定时发送电子邮件等。 https://github.com/Raikia/FiercePhish ReelPhish：是一个实时双因素网络钓鱼工具。 https://github.com/fireeye/ReelPhish/ Gophish：是一款专为企业和渗透测试人员设计的开源钓鱼攻击工具包。 https://github.com/gophish/gophish CredSniper：是一个使用Python微型框架Flask和Jinja2模板编写的网络钓鱼框架，支持捕获2FA令牌。 https://github.com/ustayready/CredSniper PwnAuth：一个让组织和渗透测试人员能够拥有测试其检测和响应OAuth滥用社会工程活动能力的平台。 https://github.com/fireeye/PwnAuth Phishing Frenzy： 一个开源的钓鱼测试工具。 https://github.com/pentestgeek/phishing-frenzy 水坑攻击BeEF：一款针对浏览器的渗透测试工具。 https://github.com/beefproject/beef 命令与控制远程访问工具Cobalt Strike：一款非常优秀的后渗透平台。 https://cobaltstrike.com/ Empire：一个纯碎的PowerShell后期漏洞利用代理工具。 https://github.com/EmpireProject/Empire Metasploit Framework：一个软件漏洞利用框架。 https://github.com/rapid7/metasploit-framework Pupy：是一个基于python的开源跨平台（Windows，Linux，OSX，Android）远程管理和后期利用工具。 https://github.com/n1nj4sec/pupy Koadic：DEFCON上的一个后渗透工具，一款js/vbs远控，模块也蛮多的，涉及的功能也很全面。 https://github.com/zerosum0x0/koadic PoshC2：一款基于PowerShell和C#的命令控制工具。 https://github.com/nettitude/PoshC2 Gcat：是一款使用Gmail控制管理的Python隐形后门。 https://github.com/byt3bl33d3r/gcat TrevorC2：是一个合法的网站（可浏览），用于隐藏命令执行的客户端/服务器通信。 https://github.com/trustedsec/trevorc2 Merlin：是一个用Go语言编写的跨平台后期利用HTTP/2命令与控制服务器和代理（ agent ）。 https://github.com/Ne0nd0g/merlin Quasar：一个用C#编码的快速轻量级远程管理工具。 https://github.com/quasar/QuasarRAT StagingRed Baron：是Terraform的一组模块和定制/第三方提供商，它试图为红队自动创建弹性，一次性，安全和灵活的基础架构。 https://github.com/Coalfire-Research/Red-Baron EvilURL：为IDN同形异义字攻击生成unicode域名并检测它们。 https://github.com/UndeadSec/EvilURL Domain Hunter：检查过期域名，bluecoat分类和Archive.org历史记录，以确定最为适合于钓鱼和C2的域名。 https://github.com/threatexpress/domainhunter PowerDNS：一个简单的PoC，用于演示如何使用DNS执行PowerShell脚本。 https://github.com/mdsecactivebreach/PowerDNS Chameleon：帮助红队将其基础架构分类为任意类别的工具。 https://github.com/mdsecactivebreach/Chameleon CatMyFish：搜索分类域。 为你的Cobalt Strike beacon C&amp;C设置白名单域。 https://github.com/Mr-Un1k0d3r/CatMyFish Malleable C2：用于重新定义Beacon通信中的指标。 https://github.com/rsmudge/Malleable-C2-Profiles Malleable-C2-Randomizer：该脚本通过使用元语言随机化Cobalt Strike Malleable C2配置文件，从而最大程度上的减少基于签名的检测控制机会。 https://github.com/bluscreenofjeff/Malleable-C2-Randomizer FindFrontableDomains：搜索潜在的frontable域。 https://github.com/rvrsh3ll/FindFrontableDomains Postfix-Server-Setup：自动化建立一个网络钓鱼服务器。 https://github.com/n0pe-sled/Postfix-Server-Setup DomainFronting：根据CDN列出Domain Frontable域列表。 https://github.com/vysec/DomainFrontingLists Apache2-Mod_rewrite-Setup：快速在你的基础架构中实现Mod_rewrite。 https://github.com/n0pe-sled/Apache2-Mod-Rewrite-Setup mod_rewrite：沙箱逃逸。 https://gist.github.com/curi0usJack/971385e8334e189d93a6cb4671238b10 external_c2 framework：允许我们使用beacon数据包并通过可选端口与Team Server进行交互。 https://github.com/Und3rf10w/external_c2_framework ExternalC2：一个用于将通信渠道与Cobalt Strike External C2服务器集成的库。 https://github.com/ryhanson/ExternalC2 cs2 mod_rewrite：用于将Cobalt Strike配置文件转换为mod_rewrite脚本的工具。 https://github.com/threatexpress/cs2modrewrite e2modrewrite：用于将Empire配置文件转换为Apache modrewrite脚本。 https://github.com/infosecn1nja/e2modrewrite Domain Fronting Google App Engine：一个云平台，允许用户构建和部署自制的Web 和 移动应用程序，它相当于一个介于应用程序和云基础设施之间的抽象层。 https://github.com/redteam-cyberark/Google-Domain-fronting 使用NGINX提供随机Payload。 https://gist.github.com/jivoi/a33ace2e25515a31aa2ffbae246d98c9 Empire自动任务执行。 https://github.com/bneg/RedTeam-Automation meek：Tor的一种传输插件，它将数据流编码为一系列HTTPS请求和响应。 https://github.com/arlolra/meek CobaltStrike-ToolKit ：一些实用的obaltStrike脚本。 https://github.com/killswitch-GUI/CobaltStrike-ToolKit 内网漫游CrackMapExec：使用Python编写的一款工具,堪称Windows活动目录/域环境渗透测试里的一把瑞士军刀。 https://github.com/byt3bl33d3r/CrackMapExec PowerLessShell：在不调用PowerShell.exe的情况下执行PowerShell脚本。 https://github.com/Mr-Un1k0d3r/PowerLessShell GoFetch：是一个自动执行由BloodHound应用程序生成的攻击计划的工具。 https://github.com/GoFetchAD/GoFetch ANGRY PUPPY：Cobalt Strike中bloodhound攻击路径自动化。 https://github.com/vysec/ANGRYPUPPY DeathStar：一键自动化域渗透工具。 https://github.com/byt3bl33d3r/DeathStar SharpHound：C#重写BloodHound Ingestor。 https://github.com/BloodHoundAD/SharpHound Responder：可用于嗅探网络内所有的LLMNR包，获取各个主机的信息，还可以发起欺骗，诱骗发起请求的主机访问错误主机的工具。 https://github.com/SpiderLabs/Responder SessionGopher：是一个PowerShell工具，它使用WMI为远程访问工具（如WinSCP，PuTTY，SuperPuTTY，FileZilla和Microsoft远程桌面）提取保存的会话信息。该工具支持远程或本地运行。 https://github.com/fireeye/SessionGopher PowerSploit：GitHub上面的一个安全项目，上面有很多powershell攻击脚本,它们主要被用来渗透中的信息侦察、权限提升、权限维持。 https://github.com/PowerShellMafia/PowerSploit Nishang：一款针对PowerShell的渗透工具。 https://github.com/samratashok/nishang Inveigh：是一款Windows PowerShell的LLMNR/NBNS协议欺骗/中间人工具。 https://github.com/Kevin-Robertson/Inveigh PowerUpSQL：攻击SQL SERVER的Powershell脚本框架。 https://github.com/NetSPI/PowerUpSQL MailSniper：Exchange敏感数据检索工具。 https://github.com/dafthack/MailSniper WMIOps：PowerShell脚本，它使用WMI在Windows环境中的本地或远程主机上执行各种操作。 https://github.com/ChrisTruncer/WMIOps Mimikatz ：一款获取windows密码的工具。 https://github.com/gentilkiwi/mimikatz LaZagne：一款用于检索大量存储在本地计算机密码的开源应用程序。 https://github.com/AlessandroZ/LaZagne mimipenguin ：一款Linux下的密码抓取神器。 https://github.com/huntergregal/mimipenguin PsExec：是一个轻型的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与控制台应用程序相当的完全交互性。 https://docs.microsoft.com/en-us/sysinternals/downloads/psexec KeeThief：允许你从内存中提取KeePass 2.X key material的工具。 https://github.com/HarmJ0y/KeeThief PSAttack：一个开源的,将渗透测试实践过程中所有的脚本结合起来形成的框架。 https://github.com/jaredhaight/PSAttack Internal Monologue攻击：在不触碰LSASS的情况下抓取 NTLM Hashes 的攻击方式。 https://github.com/eladshamir/Internal-Monologue Impacket：网络协议工具包。 https://github.com/CoreSecurity/impacket ADRecon：AD环境侦察工具。 https://github.com/sense-of-security/ADRecon icebreaker：如果你当前处于内网环境但又在AD环境之外，icebreaker将会帮助你获取明文Active Directory凭据。 https://github.com/DanMcInerney/icebreaker WSUSpendu：该脚本是由法国研究人员开发的，有了它渗透测试人员可以自主创建恶意更新，并将其注入到WSUS服务器数据库中随意的分发这些恶意更新。 https://github.com/AlsidOfficial/WSUSpendu Evilgrade ：一个模块化的脚本框架，使攻击者可以通过注射”evil”更新到不知道用户的更新。 https://github.com/infobyte/evilgrade NetRipper：是一款针对Windows操作系统的漏洞利用工具,它可以使用API hooking从一个低权限的用户那里截获网络通信数据以及与加密相关的信息，而且还可以捕获明文通信数据以及经过加密的通信数据。 https://github.com/NytroRST/NetRipper 隧道通信Tunna：一款神奇的工具，它可以通过HTTP封装隧道通信任何TCP，以及用于绕过防火墙环境中的网络限制。 https://github.com/SECFORCE/Tunna reGeorg：reDuh 的升级版，主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。 https://github.com/sensepost/reGeorg Blade：是一个基于控制台的webshell连接工具。 https://github.com/wonderqs/Blade Tinyshell：一个简易的shell命令解释器。 https://github.com/threatexpress/tinyshell PowerLurk：用于构建恶意WMI事件Subsriptions的PowerShell工具集。 https://github.com/Sw4mpf0x/PowerLurk DAMP：ACL修改项目。 https://github.com/HarmJ0y/DAMP 提权域提权PowerView：是一个PowerShell工具，用于获取Windows域的网络态势感知。 https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1 Get-GPPPassword：检索通过组策略首选项推送的帐户的明文密码和其他信息。 https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1 Invoke-ACLpwn：是一个Powershell脚本，可以使用集成的凭据或者指定的凭据来运行。这款工具的工作原理是使用SharpHound导出域内所有ACL以及当前用户账户下的组成员关系。如果用户不具备域对象的writeDACL权限，该工具会枚举域内ACL的所有ACE。 https://github.com/fox-it/Invoke-ACLPwn BloodHound：强大的内网域渗透提权分析工具。 https://github.com/BloodHoundAD/BloodHound PyKEK（Python Kerberos利用工具包），一个用于处理KRB5相关数据的python库。 https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068/pykek 本地提权UACMe：是一款开源评估工具，其中包含许多用于在多个版本的操作系统上绕过Windows用户帐户控制的方法。 https://github.com/hfiref0x/UACME windows-kernel-exploits：windows kernel exploit集合。 https://github.com/SecWiki/windows-kernel-exploits PowerUp：是本地特权提升的一些调用方法，功能相当强大，拥有众多实用的脚本来帮助我们寻找目标主机Windows服务漏洞进行提权。也是 PowerShell Empire和PowerSploit 的一部分。 https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1 The Elevate Kit：演示如何在Cobalt Strike的Beacon payload中使用PowerShell以及反射DLL exploit。 https://github.com/rsmudge/ElevateKit Sherlock：一个在Windows下用于本地提权的PowerShell脚本。 https://github.com/rasta-mouse/Sherlock Tokenvator：一款利用Windows Tokens提权的工具。 https://github.com/0xbadjuju/Tokenvator 数据盗取CloakifyFactory &amp; the Cloakify Toolset - 数据盗取，躲避DLP/MLS数据泄露防护系统，社会工程学分析，突破数据白名单控制，躲避AV检测。 https://github.com/TryCatchHCF/Cloakify DET：是一个概念界定,描述能同时使用单独或多个通道执行数据渗透。 https://github.com/sensepost/DET DNSExfiltrator ：利用DNS解析进行数据隐秘传输的工具。 https://github.com/Arno0x/DNSExfiltrator PyExfil：用于数据盗取的PyExfil Python软件包。 https://github.com/ytisf/PyExfil Egress-Assess：一个通过多种协议模拟数据渗透的工具。 https://github.com/ChrisTruncer/Egress-Assess PowerShell-RAT：一款基于Python的后门程序。它不仅可以使用屏幕捕捉功能来跟踪用户的活动，而且还可以通过电子邮件附件来将提取出的数据发送给攻击者。 https://github.com/Viralmaniar/Powershell-RAT 杂项无线网络Wifiphisher：能够对WPA加密的AP无线热点实施自动化钓鱼攻击，并获取密码账户。 https://github.com/wifiphisher/wifiphisher Evilginx：可绕过双因素验证的高级钓鱼框架。 https://github.com/kgretzky/evilginx Mana：是一款国外安全人员为测试而开发的Wifi劫持工具，可以监听计算机或其他移动设备的Wifi通信，并能够模仿该设备。 https://github.com/sensepost/mana 嵌入式和外围设备渗透MagSpoof：能预测并窃取你下一张信用卡号码的廉价设备 。 https://github.com/samyk/magspoof WarberryPi：为了“红队判研”（red teaming）而创建，因为在“红队判研”中，我们想在短时间内尽可能隐秘地获取更多信息。只要找到一个网络端口，插入即可。脚本的设计主要是通过找到 避免网络内噪声被发现且尽可能有效的方法加以实现。WarBerry脚本集扫描工具于一体，从而实现该功能。 https://github.com/secgroundzero/warberry P4wnP1 ：为树莓派安装网络劫持键盘注入(WHID)工具。 https://github.com/mame82/P4wnP1 malusb：创建跨平台的HID欺骗payload，并在Windows和OSX上建立反向TCP-shell。 https://github.com/ebursztein/malusb Fenrir：是一款设计用于渗透测试的“开箱即用”工具。其主要功能和用途是绕过有线802.1x保护并使你能够访问目标网络。 https://github.com/Orange-Cyberdefense/fenrir-ocd 团队沟通Rocket.Chat：一个功能强大的团队合作聊天工具。 https://rocket.chat/ EtherPad：多人即时文件协作平台。 https://etherpad.net/ 脚本Aggressor脚本：大多数Cobalt Strike对话框和功能都是作为独立模块编写的，这些模块向Aggressor Script引擎提供了一些接口如default.cna定义了默认的Cobalt Strike的工具栏按钮，弹出式菜单，除此之外可以利用提供的API来模拟红队成员与你并肩作战以及扩展跟修改Cobalt Strike的现有功能等。 https://github.com/invokethreatguy/CSASC https://github.com/secgroundzero/CS-Aggressor-Scripts https://github.com/Und3rf10w/Aggressor-scripts https://github.com/harleyQu1nn/AggressorScripts https://github.com/rasta-mouse/Aggressor-Script https://github.com/RhinoSecurityLabs/Aggressor-Scripts https://github.com/bluscreenofjeff/AggressorScripts https://github.com/001SPARTaN/aggressor_scripts 适用于红队和渗透测试的脚本：https://github.com/FuzzySecurity/PowerShell-Suite https://github.com/nettitude/Powershell https://github.com/Mr-Un1k0d3r/RedTeamPowershellScripts https://github.com/threatexpress/red-team-scriptsh https://github.com/SadProcessor/SomeStuff https://github.com/rvrsh3ll/Misc-Powershell-Scripts https://github.com/enigma0x3/Misc-PowerShell-Stuff https://github.com/ChrisTruncer/PenTestScripts https://github.com/bluscreenofjeff/Scripts https://github.com/xorrior/RandomPS-Scripts https://github.com/xorrior/Random-CSharpTools https://github.com/leechristensen/Random https://github.com/mgeeky/Penetration-Testing-Tools/tree/master/social-engineering 参考MITRE’s ATT&amp;CK是一个向美国政府提供系统工程、研究开发和信息技术支持的美国非营利性组织。基于ATT&amp;CK（对抗战术、技术与常识）知识库的端点检测和响应（EDR）产品进行评估，以加强行业和客户的网络攻击对策。 https://attack.mitre.org/wiki/Main_Page 涵盖多个项目的速查手册（Beacon / Cobalt Strike，PowerView，PowerUp，Empire和PowerSploit）。 https://github.com/HarmJ0y/CheatSheets PRE-ATT&amp;CK对抗战术，技术和通用知识： https://attack.mitre.org/pre-attack/index.php/Main_Page Adversary OPSEC包括使用各种技术或第三方服务来混淆，隐藏网络流量或系统行为： https://attack.mitre.org/pre-attack/index.php/Adversary_OPSEC 为了展示ATT＆CK对于攻击性运营商和防御者的实际使用，MITRE创建了Adversary Emulation Plans： https://attack.mitre.org/wiki/Adversary_Emulation_Plans 红色团队维基基础架构： https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki Advanced Threat Tactics（高级威胁战术） – 课程和笔记。关于红队运作和对手模拟的免费课程。 https://blog.cobaltstrike.com/2015/09/30/advanced-threat-tactics-course-and-notes @vysecurityz在Twitter上的关于红队Tips的文章。https://vincentyiu.co.uk/red-team-tips 优秀红队资源列表： https://github.com/yeyintminthuhtut/Awesome-Red-Teaming 用于企业软件的ATT＆C：。 https://attack.mitre.org/wiki/Software 红队练习计划： https://github.com/magoo/redteam-plan 关于锁，保险箱和钥匙安全性的资源精选列表。 https://github.com/meitar/awesome-lockpicking 优秀的威胁情报资源精选列： https://github.com/hslatman/awesome-threat-intelligence APTnotes是一个按年份排序用于存储各种APT相关的公开可用文档和记录的存储库。 https://github.com/aptnotes/data TIBER-EU框架是欧洲首个针对可控网络黑客行为的框架，可在多个当局监督的情况下测试跨境实体的网络弹性。 http://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试神器——搜索引擎]]></title>
    <url>%2Faisnnu.github.io%2Funcategorized%2Faisnnu0%2F</url>
    <content type="text"><![CDATA[搜索引擎是我日常工作中用得最多的一款工具，国内常用的搜索引擎包括Baidu，sougou，bing等。但我本篇要纪录的并不是这些常用的搜索引擎，而是信息安全从业人员必备的几款网络搜索引擎。本篇要介绍的搜索引擎包括：Shodan，censys，钟馗之眼，Google，FoFa，Dnsdb等。介绍的内容主要是这几款搜索引擎的一些高级语法，掌握高级语法会让搜索结果更准确。 Google搜索引擎这里之所以要介绍google搜索引擎，是因为它有别于百度、搜狗等内容搜索引擎，其在安全界有着非同一般的地位，甚至专门有一名词为google hacking用来形容google与安全非同寻常的关系。 google基本语法Index of/ 使用它可以直接进入网站首页下的所有文件和文件夹中。intext: 将返回所有在网页正文部分包含关键词的网页。intitle: 将返回所有网页标题中包含关键词的网页。cache: 搜索google里关于某些内容的缓存。define: 搜索某个词语的定义。filetype: 搜索指定的文件类型，如：.bak，.mdb，.inc等。info: 查找指定站点的一些基本信息。inurl: 搜索我们指定的字符是否存在于URL中。Link: link:thief.one可以返回所有和thief.one做了链接的URL。site: site:thief.one将返回所有和这个站有关的URL。+ 把google可能忽略的字列如查询范围。- 把某个字忽略，例子：新加 -坡。~ 同意词。. 单一的通配符。* 通配符，可代表多个字母。“” 精确查询。 搜索不同国家网站inurl:tw 台湾inurl:jp 日本 利用google暴库利用goole可以搜索到互联网上可以直接下载到的数据库文件，语法如下： inurl:editor/db/ inurl:eWebEditor/db/ inurl:bbs/data/ inurl:databackup/ inurl:blog/data/ inurl:\boke\data inurl:bbs/database/ inurl:conn.asp inc/conn.asp Server.mapPath(“.mdb”) allinurl:bbs data filetype:mdb inurl:database filetype:inc conn inurl:data filetype:mdb intitle:”index of” data 利用goole搜索敏感信息利用google可以搜索一些网站的敏感信息，语法如下: intitle:”index of” etc intitle:”Index of” .sh_history intitle:”Index of” .bash_history intitle:”index of” passwd intitle:”index of” people.lst intitle:”index of” pwd.db intitle:”index of” etc/shadow intitle:”index of” spwd intitle:”index of” master.passwd intitle:”index of” htpasswd inurl:service.pwd 利用google搜索C段服务器信息site:218.87.21.* 可通过google可获取218.87.21.0/24网络的服务信息。 shodan搜索引擎shodan网络搜索引擎偏向网络设备以及服务器的搜索，具体内容可上网查阅，这里给出它的高级搜索语法。 地址：https://www.shodan.io/ shodan搜索语法hostname： 搜索指定的主机或域名，例如 hostname:”google” port： 搜索指定的端口或服务，例如 port:”21” country： 搜索指定的国家，例如 country:”CN” city： 搜索指定的城市，例如 city:”Hefei” org： 搜索指定的组织或公司，例如 org:”google” isp： 搜索指定的ISP供应商，例如 isp:”China Telecom” product： 搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version： 搜索指定的软件版本，例如 version:”1.6.2” geo： 搜索指定的地理位置，例如 geo:”31.8639, 117.2808” before/after： 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15” net： 搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” 以上内容参考：http://xiaix.me/shodan-xin-shou-ru-keng-zhi-nan/ censys搜索引擎censys搜索引擎功能与shodan类似，以下几个文档信息。 地址：https://www.censys.io/ https://www.censys.io/certificates/help 帮助文档 https://www.censys.io/ipv4?q= ip查询 https://www.censys.io/domain?q= 域名查询 https://www.censys.io/certificates?q= 证书查询 censys搜索语法默认情况下censys支持全文检索。 23.0.0.0/8 or 8.8.8.0/24 可以使用and or not 80.http.get.status_code: 200 指定状态 80.http.get.status_code:[200 TO 300] 200-300之间的状态码 location.country_code: DE 国家 protocols: (“23/telnet” or “21/ftp”) 协议 tags: scada 标签 80.http.get.headers.server：nginx 服务器类型版本 autonomous_system.description: University 系统描述 zoomeye钟馗之眼钟馗之眼搜索引擎偏向web应用层面的搜索。 地址：https://www.zoomeye.org/ zoomeye钟馗之眼搜索语法app:nginx 组件名 ver:1.0 版本 os:windows 操作系统 country:”China” 国家 city:”hangzhou” 城市 port:80 端口 hostname:google 主机名 site:thief.one 网站域名 desc:nmask 描述 keywords:nmask’blog 关键词 service:ftp 服务类型 ip:8.8.8.8 ip地址 cidr:8.8.8.8/24 ip地址段 FoFa搜索引擎FoFa搜索引擎偏向资产搜索。 地址：https://fofa.so FoFa搜索语法title=”abc” 从标题中搜索abc。例：标题中有北京的网站。 header=”abc” 从http头中搜索abc。例：jboss服务器。 body=”abc” 从html正文中搜索abc。例：正文包含Hacked by。 domain=”qq.com” 搜索根域名带有qq.com的网站。例： 根域名是qq.com的网站。 host=”.gov.cn” 从url中搜索.gov.cn,注意搜索要用host作为名称。 port=”443” 查找对应443端口的资产。例： 查找对应443端口的资产。 ip=”1.1.1.1” 从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称。 protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)。例： 查询https协议资产。 city=”Beijing” 搜索指定城市的资产。例： 搜索指定城市的资产。 region=”Zhejiang” 搜索指定行政区的资产。例： 搜索指定行政区的资产。 country=”CN” 搜索指定国家(编码)的资产。例： 搜索指定国家(编码)的资产。 cert=”google.com” 搜索证书(https或者imaps等)中带有google.com的资产。 高级搜索title=”powered by” &amp;&amp; title!=discuz title!=”powered by” &amp;&amp; body=discuz ( body=”content=\”WordPress” || (header=”X-Pingback” &amp;&amp; header=”/xmlrpc.php” &amp;&amp; body=”/wp-includes/“) ) &amp;&amp; host=”gov.cn” Dnsdb搜索引擎dnsdb搜索引擎是一款针对dbs解析的查询平台。 地址：https://www.dnsdb.io/ Dnsdb搜索语法DnsDB查询语法结构为条件1 条件2 条件3 …., 每个条件以空格间隔, DnsDB 会 把满足所有查询条件的结果返回给用户. 域名查询条件域名查询是指查询顶级私有域名所有的DNS记录, 查询语法为domain:. 例如查询google.com 的所有DNS记录: domain:google.com. 域名查询可以省略domain:. 主机查询条件查询语法:host: 例如查询主机地址为mp3.example.com的DNS记录: host:map3.example.com 主机查询条件与域名查询查询条件的区别在于, 主机查询匹配的是DNS记录的Host值 按DNS记录类型查询查询语法: type:.例如只查询A记录: type:a使用条件:必须存在domain:或者host:条件,才可以使用type:查询语法 按IP限制查询语法: ip:查询指定IP: ip:8.8.8.8, 该查询与直接输入8.8.8.8进行查询等效查询指定IP范围: ip:8.8.8.8-8.8.255.255CIDR: ip:8.8.0.0/24IP最大范围限制65536个]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涉密不上网，上网不涉密。]]></title>
    <url>%2Faisnnu.github.io%2Funcategorized%2Faisnnu3%2F</url>
    <content type="text"><![CDATA[网络安全为人民，网络安全靠人民。不可不说的信息安全事件1、2010年，”震网”病毒，全球第一列被发现针对工控系统的网络病毒 2、2013年6月，棱镜门事件，斯诺登外逃 3、2014年5月，eBay被攻击导致1亿多用户账户信息泄露 4、2016年9月，Dropbox6800万账户密码遭泄露 5、2016年12月，雅虎曝史上最大规模信息泄露，10亿用户资料被窃 6、2017年5月，WannaCry病毒席卷全球 7、2017年9月，美国征信巨头Equifax数据库遭攻击，近1.43亿个人信息泄露，占美国人口的一半 8、2018年3月，Facebook爆出史上最大数据泄露事件 9、2018年8月，华住集团5亿条酒店信息泄露 网络安全问题越来越受到全世界的关注 越来越多白帽子正在网络世界里与黑灰产作斗争]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
